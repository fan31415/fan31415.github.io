<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo-32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo-16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.ong?v=5.1.4" color="#222">





  <meta name="keywords" content="fanyijie, technology" />










<meta property="og:type" content="website">
<meta property="og:title" content="Fan&#39;s Home">
<meta property="og:url" content="https://fanyijie.net/page/4/index.html">
<meta property="og:site_name" content="Fan&#39;s Home">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fan&#39;s Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanyijie.net/page/4/"/>





  <title>Fan's Home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fan's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/24/subset-enumeration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/24/subset-enumeration/" itemprop="url">枚举子集</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-24T15:31:03+08:00">
                2016-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/回溯/算法学习/" itemprop="url" rel="index">
                    <span itemprop="name">算法学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里我们讨论没有重复元素集合的非空子集枚举方法。 <strong>1.增量构造</strong> 最基本的想法就是像构造全排列那样，每次遍历所有当前可能向集合中添加的值，添加进去然后递归。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void add_subset(int n, int *A, int cur){<br>    for(int i = 0; i &lt; cur; i++){    //打印当前枚举到的集合<br>        cout&lt;&lt;A[i]&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>    int s;<br>    if(cur){    //确定当前可向集合中添加的元素的最小可能值<br>        s = A[cur-1] + 1;<br>    }else{<br>        s = 0;<br>    }<br>    for(int i = s; i &lt; n; i++){    //遍历当前所有可能取值，从当前最小可能值到集合最大值<br>        A[cur] = i;<br>        add_subset(n, A, cur+1);    //递归构造<br>    }<br>}<br>int main(){<br>    int A[99] = {0};<br>    int n;<br>    cin&gt;&gt;n;<br>    add_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0<br>0 1<br>0 1 2<br>0 2<br>1<br>1 2<br>2</p>
<p>这里我们把集合元素从0到n-1进行编号，输出中的一行代表其中一个子集中的各元素编号。 这个算法的解答树共有2^n个节点。 <strong>2.位向量构造</strong> 这里我们构造一个位向量A[i], A[i] = 1代表i出现在了子集中。这个算法很好理解，从cur = 0时开始构造子集，每一次递归只用考虑选第i个元素和不选第i个元素两种情况，递归n次即可包括2^n个子集的情况，当cur == n时则说明已经构造出了当前选择下的子集，打印输出即可。不过这个算法的解答树有2^(n+1) - 1个节点，因为每一个未完成的解也会占用一个节点。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void pos_subset(int n,int *A,int cur){<br>    if(cur == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(A[i]){<br>                cout&lt;&lt;i&lt;&lt;” “;<br>            }<br>        }<br>        cout&lt;&lt;endl;<br>        return;<br>    }<br>    A[cur] = 1;<br>    pos_subset(n, A, cur + 1);<br>    A[cur] = 0;<br>    pos_subset(n, A, cur +1);<br>}<br>int main(){<br>    int A[99]={0};<br>    int n;<br>    cin&gt;&gt;n;<br>    pos_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0 1 2<br>0 1<br>0 2<br>0<br>1 2<br>1<br>2</p>
<p>输出的定义同上。 <strong>3.二进制法</strong> 这里我们用一个二进制数来表示子集S，比如10111，即表示0,1,2,4号元素均在子集S中。也就是说，二进制数从右往左数第i位如果是1，那么该二进制数代表的集合中有元素i，0则没有。 按照这个定义，我们可以写出下面的代码来枚举子集：</p>
<p>#include<iostream><br>using namespace std;<br>void binary_subset(int n, int s){<br>    for(int i = 0; i &lt; n; i++){<br>        if(s &amp; (1 &lt;&lt; i)){<br>            cout&lt;&lt;i&lt;&lt;” “;<br>        }<br>    }<br>    cout&lt;&lt;endl;<br>}<br>int main(){<br>    int n, s;<br>    cin&gt;&gt;n;<br>    for(int i = 0; i &lt; (1 &lt;&lt; n); i++){<br>        binary_subset(n, i);<br>    } </iostream></p>
<p>}</p>
<p>测试输入：3 测试输出：</p>
<p>0<br>1<br>0 1<br>2<br>0 2<br>1 2<br>0 1 2</p>
<p>在main函数中我们枚举了子集对应的编码0到2^n-1,而binary_subset函数则负责打印编码的二进制形式所对应的子集。binary_subset函数其实就是将从右往左看子集编码的每一位是否是1，是1就打印出当前位代表的元素,和位向量法的打印是一个方法。 输出分析：输入3，然后main函数从0开始循环到2^3-1，首先是i=0，进入子集函数，s=0，无输出。main函数循环到1,子集函数1&amp;1为真，输出i=0。继续子集函数进来2=10(2)，仅第二位为1，说明该集合只取了元素1（我们从0开始编码)，于是输出该集合包含的元素1,。接着进来3=11(2)，该集合取了元素0和1，则输出0,1.以此类推直到最后循环到7=111（2),输出该集合0,1,2,至此就将含有三个元素的集合的2^n-1个非空子集枚举完了。 这里注意一下，二进制法用int存i的话，最多只能输出n=30时的集合的子集。因为int最大只有2^31-1. <strong>二进制法的一个更简洁的写法</strong> 这里先贴代码：</p>
<p>#include<iostream><br>using namespace std;<br>void print_subset(int i,int n){    //打印i的二进制形式所对应的集合的所有元素<br>    for(int j = 0; j &lt; n; j++){<br>            if(i &amp; 1&lt;&lt;j){<br>                cout &lt;&lt; j &lt;&lt;” “;<br>            }<br>        }<br>        cout &lt;&lt; endl;<br>}<br>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = n; i; i = (i - 1) &amp; n){<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>    }<br>}<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;    //输入一个数n，对应其二进制形式所代表的集合<br>    binary_subset(n);    //输出n对应集合的所有子集的编码以及每个子集中的元素 </iostream></p>
<p>}</p>
<p>其中的关键语句就只有一句</p>
<p>for(int i = n; i; i = (i - 1) &amp; n)</p>
<p>就是这句话完成了对n所代表集合的子集的枚举。而print_subset函数只是用来打印出枚举出的子集i的元素的。 这句话的关键在于i = (i - 1) &amp; n这儿，其实就是多了一个&amp;n来把n中为0的数位在自减中过滤掉了。举个栗子，输入11，即1011(2),那么这个集合含有元素0,1,3，我们做这个循环的更新，会依次得到如下的i ：</p>
<p>1011    //n的初始值，二进制形式 </p>
<p>1010    //第一次循环<br>1001    //第二次循环<br>1000    //…<br>0011<br>0010<br>0001    //当i为0000时集合为空</p>
<p>可以看出对应111,110,101,100,011,010,001. 下面可以看一下测试运行的结果，测试输入：11 测试输出：</p>
<p>11 :0 1 3<br>10 :1 3<br>9 :0 3<br>8 :3<br>3 :0 1<br>2 :1<br>1 :0</p>
<p>和我们之前分析的是一致的。 附上写法的<strong>正序版本</strong></p>
<p>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = 0; ; i = (i - n) &amp; n){    //正序<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>        if( i == n) break;<br>    }<br>}</p>
<p>输入：11 输出：</p>
<p>0 :<br>1 :0<br>2 :1<br>3 :0 1<br>8 :3<br>9 :0 3<br>10 :1 3<br>11 :0 1 3</p>
<p>另外注意当被枚举的集合n固定为2^n-1时，这样的写法就失去了意义，而退化到二进制法的情况，这时直接写</p>
<p>for(int i = 0; i &lt; (1&lt;&lt;n); i++)</p>
<p>从1到2^n-1遍历即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/23/uva-140-bandwidth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/23/uva-140-bandwidth/" itemprop="url">Uva 140 Bandwidth</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-23T22:18:50+08:00">
                2016-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva 140 Bandwidth</strong> Given a graph (V,E) where V is a set of nodes and E is a set of arcs in VxV, and an ordering on the elements in V, then the bandwidth of a node v is defined as the maximum distance in the ordering between v and any node to which it is connected in the graph. The bandwidth of the ordering is then defined as the maximum of the individual bandwidths. For example, consider the following graph: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img1.gif" alt="140img1"> This can be ordered in many ways, two of which are illustrated below: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img2-300x34.gif" alt="140img2"> For these orderings, the bandwidths of the nodes (in order) are 6, 6, 1, 4, 1, 1, 6, 6 giving an ordering bandwidth of 6, and 5, 3, 1, 4, 3, 5, 1, 4 giving an ordering bandwidth of 5. Write a program that will find the ordering of a graph that minimises the bandwidth. <strong>Input</strong> Input will consist of a series of graphs. Each graph will appear on a line by itself. The entire file will be terminated by a line consisting of a single #. For each graph, the input will consist of a series of records separated by <code>;&#39;. Each record will consist of a node name (a single upper case character in the the range \</code>A’ to `Z’), followed by a `:’ and at least one of its neighbours. The graph will contain no more than 8 nodes. <strong>Output</strong> Output will consist of one line for each graph, listing the ordering of the nodes followed by an arrow (-&gt;) and the bandwidth for that ordering. All items must be separated from their neighbours by exactly one space. If more than one ordering produces the same bandwidth, then choose the smallest in lexicographic ordering, that is the one that would appear first in an alphabetic listing. <strong>Sample input</strong> A:FB;B:GC;D:GC;F:AGH;E:HD # <strong>Sample output</strong> A B C F G D H E -&gt; 3 题意：输入一个无向图G，定义一个由图的顶点构成的排列P. 定义任意一个顶点i的带宽b(i), 为i顶点与其相邻顶点在排列P中的最远距离。取所有顶点的b(i)的最大值为整个图G的bandwidth. 要求输出一个让bandwidth最小的顶点排列并输出其bandwidth值. 思路：因为图顶点数&lt;=8, 排列数小于100000, 所以这里直接用的暴力枚举。首先读入一行数据，然后用strchr函数(返回字符串str中第一次出现字符ch时的指针，如果没有出现则返回NULL)对本次输入出现的字母进行编号。通过mapc数组得到从编号到字母的映射，通过id数组得到字母到其编号的映射。 然后遍历输入，直接用向量u，v储存所有相邻的顶点，在循环中，u反复存储当前顶点，而对应的v则存入其相邻顶点，直到分号输入为止。这样就将所有会用来计算带宽的点对对应的存入了u，v中。 最后通过c++自带的next_permutation函数按字典序生成全排列。先初始化最小字典序全排列，然后循环生成。 这道题除了暴力的做法，还可以回溯剪枝，而且显然更快。这儿先留着下次有时间再写。 ac代码：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring></cstring></p>
<p>#include<algorithm></algorithm></p>
<p>#include<cmath></cmath></p>
<p>#include<vector></vector></p>
<p>#define N 10<br>using namespace std;<br>char in[100];<br>char mapc[30];<br>int id[30];<br>vector<int> u, v;<br>int main(){<br>    while(~scanf(“%s”,&amp;in) &amp;&amp; in[0] != ‘#’){<br>        int p = 0, num = 0, flag = 0;<br>        for(char a = ‘A’; a &lt;= ‘Z’; a++){<br>            if(strchr(in, a) != NULL){<br>                mapc[num] = a;<br>                id[a] = num;<br>                num++;<br>            }<br>        }<br>        char ch;<br>        int len = strlen(in);<br>        for(int i = 0; i &lt; len; i++){<br>            if(in[i] == ‘:’){<br>                flag = 1;<br>            }<br>            if(!flag){<br>                ch = in[i];<br>            }<br>            if(flag &amp;&amp; in[i] != ‘:’){<br>                if(in[i] != ‘;’){<br>                    u.push_back(id[ch]);<br>                    v.push_back(id[in[i]]);<br>                }<br>                else{<br>                    flag = 0;<br>                }<br>            }</int></p>
<pre><code>    }
    int pa\[N\], ans\[N\], pos\[N\], bw = 0x3f3f3f3f;
    for(int i = 0; i &lt; num; i++){
        pa\[i\] = i;
    }
    do{
        for(int i = 0; i &lt; num; i++){
            pos\[pa\[i\]\] = i;
        } 
        int b = 0;
        for(int i = 0; i &lt; u.size(); i++){
            b = max(b, abs(pos\[u\[i\]\]-pos\[v\[i\]\]));
        }
        if(b &lt; bw){
            bw = b;
            memcpy(ans, pa, sizeof(pa));
        }
    }while(next_permutation(pa, pa + num));
    for(int i = 0; i &lt; num; i++){
        printf(&quot;%c &quot;, mapc\[ans\[i\]\]);
    }
    printf(&quot;-&gt; %d\\n&quot;, bw);
    u.clear();
    v.clear();
    memset(mapc, 0, sizeof(mapc));
    memset(in, 0, sizeof(in));
    memset(id, 0, sizeof(id));
}
return 0;
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/18/uva-129-krypton-factor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/18/uva-129-krypton-factor/" itemprop="url">Uva 129 Krypton Factor</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-18T15:58:52+08:00">
                2016-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva 129 Krypton Factor</strong> You have been employed by the organisers of a Super Krypton Factor Contest in which contestants have very high mental and physical abilities. In one section of the contest the contestants are tested on their ability to recall a sequence of characters which has been read to them by the Quiz Master. Many of the contestants are very good at recognising patterns. Therefore, in order to add some difficulty to this test, the organisers have decided that sequences containing certain types of repeated subsequences should not be used. However, they do not wish to remove all subsequences that are repeated, since in that case no single character could be repeated. This in itself would make the problem too easy for the contestants. Instead it is decided to eliminate all sequences containing an occurrence of two adjoining identical subsequences. Sequences containing such an occurrence will be called ``easy’’. Other sequences will be called ``hard’’. For example, the sequence ABACBCBAD is easy, since it contains an adjoining repetition of the subsequence CB. Other examples of easy sequences are: BB ABCDACABCAB ABCDABCD Some examples of hard sequences are: D DC ABDAB CBABCBA <strong>Input and Output</strong> In order to provide the Quiz Master with a potentially unlimited source of questions you are asked to write a program that will read input lines that contain integers n and L (in that order), where n &gt; 0 and L is in the range 1 &lt;= L &lt;= 26 , and for each input line prints out the nth hard sequence (composed of letters drawn from the first L letters in the alphabet), in increasing alphabetical order (alphabetical ordering here corresponds to the normal ordering encountered in a dictionary), followed (on the next line) by the length of that sequence. The first sequence in this ordering is A. You may assume that for given n and L there do exist at least n hard sequences. For example, with L = 3, the first 7 hard sequences are: A AB ABA ABAC ABACA ABACAB ABACABA As each sequence is potentially very long, split it into groups of four (4) characters separated by a space. If there are more than 16 such groups, please start a new line for the 17th group. Therefore, if the integers 7 and 3 appear on an input line, the output lines produced should be ABAC ABA 7 Input is terminated by a line containing two zeroes. Your program may assume a maximum sequence length of 80. <strong>Sample Input</strong> 30 3 0 0 <strong>Sample Output</strong> ABAC ABCA CBAB CABA CABC ACBA CABA 28 题意：输入n和l,输出字典序第n小的hard串。 hard的定义是字符串中不包含相邻的重复子串。字符串由A, B, C,…,从A开始的l个字母构成。 思路：和生成全排列的方法类似，每次向当前位置尝试添加一个字母，如果该字母和之前已放置的字母冲突，则按字典序继续循环尝试放置下一个字母，直到不冲突的时候就放置进去并进入下一层（下一位置）的递归。 递归的边界条件在这里需要一个全局变量cnt来判断。由于每进一次递归，cnt都会++, 而一旦能进入一次递归，则说明已经又找到了一个hard串了，所以当cnt++ == n,即cnt == n时，正好是字典序第n小的hard串生成完成的时候。这时候也就是递归成功的边界条件了. 这里由于只要达到目标就不用继续搜索下去，所以在边界条件中有return 0,表示搜索成功，这样在上一层递归if(!dfs(cur+1)) return 0 中，就可以直接继续return 0跳过循环退出,然后一层层快速跳出递归，避免无用搜索。如果走到叶子节点也未找到解，就会执行最后的return 1返回父节点，然后继续循环遍历父节点剩下的儿子。如果儿子遍历完仍未找到解，则会继续返回上一层父节点，然后继续遍历深入，直到搜索完所有节点或者找到解为止。 这里取值i是否尝试成功的条件判断，是通过遍历了当前字符串长度cur+1范围内所有偶数长度的后缀，循环进行测试而得到的。 对于每一次的尝试取值i，检查所有偶数长度的后缀。每次检查当前2*j长度的后缀的前一半和后一半是否完全相同。如果有一个字符不同，则eq = 0并break，说明对于当前后缀是没有重复的，j++并对下一个后缀长度2*j再次测试。 如果测试完所有能取到的后缀长度后，均没有发现重复子串，则说明字符串是ok的，可以进入下一个位置的递归；而只要其中有一次发现了重复子串，则eq = 1，ok = 0，不是hard串，无法进入下一位置的递归，只能对当前位置的取值i继续按字典序进行循环尝试，直到将循环完毕返回父节点或找到解退出递归为止。 ac代码如下：</p>
<p>#include<cstdio><br>using namespace std;<br>int n, l, cnt;<br>int S[82];<br>int dfs(int cur){    //return 0 means solution has found<br>    if(cnt++ == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(i &amp;&amp; i % 64 == 0) printf(“\n”);<br>            else if(i &amp;&amp; i % 4 == 0) printf(“ “);<br>            printf(“%c”, ‘A’+S[i]);<br>        }<br>        printf(“\n%d\n”, cur);<br>        return 0;<br>    }<br>    for(int i = 0; i &lt; l; i++){<br>        S[cur] = i;<br>        bool ok = 1;<br>        for(int j = 1; j*2 &lt;= cur+1; j++){    //每添加一个数，就对所有后一半包含新数的后缀进行测试<br>            bool eq = 1;<br>            for(int k = 0; k &lt; j; k++){        //测试当前后缀长度下，后缀的前一半是否等于后一半<br>                if(S[cur-k] != S[cur-k-j]){    //对前一半和后一半的对应字符逐个比较<br>                    eq = 0;<br>                    break;<br>                }<br>            }<br>            if(eq){<br>                ok = 0;<br>                break;<br>            }<br>        }<br>        if(ok){<br>            if(!dfs(cur+1)){    // 如果已经找到解，则退出<br>                return 0;<br>            }<br>        }</cstdio></p>
<pre><code>}
return 1;
</code></pre><p>}<br>int main(){<br>    while(scanf(“%d%d”, &amp;n, &amp;l) == 2 &amp;&amp; n){<br>        cnt = 0;<br>        dfs(0);<br>    }<br>    return 0;<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/18/uva-524-prime-ring-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/18/uva-524-prime-ring-problem/" itemprop="url">Uva 524 Prime Ring Problem</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-18T14:10:44+08:00">
                2016-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/数论/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva 524 Prime Ring Problem</strong> A ring is composed of n (even number) circles as shown in diagram. Put natural numbers 1, 2, . . . , n into each circle separately, and the sum of numbers in two adjacent circles should be a prime. Note: the number of first circle should always be 1. <strong>Input</strong> n (0 &lt; n ≤ 16) <strong>Output</strong> The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements. You are to write a program that completes above process. <strong>Sample Input</strong> 6 8 <strong>Sample Output</strong> Case 1: 1 4 3 2 5 6 1 6 5 2 3 4 Case 2: 1 2 3 8 5 6 7 4 1 2 5 8 3 4 7 6 1 4 7 6 5 8 3 2 1 6 7 4 3 8 5 2 题意：生成一个素数环，使得相邻两个整数之和为素数，包括首尾。素数环由1~n组成，输出从1开始逆时针排列。 思路：和生成全排列的模型类似，直接递归深度优先遍历解答树，递归边界条件为cur == n且第一个数和最后一个数之和为素数，尝试取值的循环直接从2到n即可，因为要求从1开始输出，所以1每次直接加到输出数组第一个就行了。 尝试是否成功的判断条件就很简单了，一个通用的!vis[i] 和 !icp[i + A[cur-1]]，即i这个数没有被用到过且i和前一个放置的数之和为素数即可。这里素数的判定用的是先素数筛法生成素数表，然后直接用素数表判断的。 注意一下输出排列时，有一个if(i) printf(“ “)，以防止在一个排列最后同时输出空格与换行而PE. ac代码如下：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath></cmath></p>
<p>#include<cstring><br>using namespace std;<br>int n,A[99];<br>bool vis[99];<br>bool isc[101];<br>void get_prime(int n){<br>    int m=sqrt(n+0.5);<br>    for(int i = 2; i &lt;= m; i++){<br>        if(!isc[i]){<br>            for(int j = i*i; j &lt;= n; j+=i){<br>                isc[j] = 1;<br>            }<br>        }<br>    }<br>}<br>void dfs(int cur){<br>    if(cur == n &amp;&amp; !isc[A[0] + A[n-1]]){<br>        for(int i = 0; i &lt; n; i++){<br>            if(i) printf(“ “);<br>            printf(“%d”,A[i]);<br>        }<br>        printf(“\n”);<br>    }<br>    else for(int i = 2; i &lt;= n; i++){<br>        if(!vis[i] &amp;&amp; !isc[i+A[cur-1]]){<br>            A[cur] = i;<br>            vis[i] = 1;<br>            dfs(cur+1);<br>            vis[i] = 0;<br>        }<br>    }<br>}<br>int main(){<br>    get_prime(100);<br>    isc[0]=isc[1]=1;<br>    int kase = 0;<br>    while(~scanf(“%d”, &amp;n)){<br>        if(kase &gt; 0) printf(“\n”);<br>        printf(“Case %d:\n”, ++kase);<br>        memset(vis, 0, sizeof(vis));<br>        A[0] = 1;<br>        dfs(1);<br>    }<br>    return 0;<br>}</cstring></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/18/hdu-4548-beautiful-prime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/18/hdu-4548-beautiful-prime/" itemprop="url">Hdu 4548 美素数</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-18T13:10:14+08:00">
                2016-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/" itemprop="url" rel="index">
                    <span itemprop="name">A题</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/数论/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Hdu 4548 美素数</strong> <strong>Problem Description</strong> 小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。 问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。 给定一个区间，你能计算出这个区间内有多少个美素数吗？ <strong>Input</strong> 第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。 接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。 <strong>Output</strong> 对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。 每组数据占一行，具体输出格式参见样例。 <strong>Sample Input</strong> 3 1 100 2 2 3 19 <strong>Sample Output</strong> Case #1: 14 Case #2: 1 Case #3: 4 这道题我的做法是先将1~1000000的素数表打出来，用素数筛法得到，然后再遍历一遍1到1000000，得到从1到每个位置的美素数个数并将其存入arr数组中，这样每次询问只需要将arr[R]-arr[L-1]即可得到结果。素数筛法的时间复杂度是O(n*logn),遍历数组O(n),总时间复杂度近似为O(n*logn)，是有效算法。 素数筛法即对于不超过n的每个非负整数p, 删除2*p,3*p,….,当处理完所有数后，剩下的没被删的就是素数。由于每次对p进行处理时，时，(p-1)*p,(p-2)*p,…,2*p, 都已经在处理p-1,p-2,…,2时删除过了，所有就不用重复删了，直接从p*p开始删除即可，一直删到n. 由于从p*p开始，所以p也只用取到sqrt(n)就行了。由于sqrt返回double，而我们要取整，为了保险起见取到sqrt(n+0.5)。此外，由于每个数都有素因子，所以对于已经被判定是合数的数，就不用对其处理了，可以加上判断减少循环。 整个素数筛法代码如下：</p>
<p>void get_prime(int n){<br>    int m = sqrt(n+0.5);<br>    memset(mark,0,sizeof(mark));<br>    for(int i = 2; i &lt;= m; i++){<br>        if(!mark[i]){<br>            for(int j = i*i; j &lt;= n; j+=i){<br>                mark[j] = 1;<br>            }<br>        }<br>    }<br>}</p>
<p>mark[j]=1代表该数已被删除，处理完所有数后mark[j]==0的即是素数。 另外一个要用到的函数就是求数字各位和的函数，这个就很基础了，每次n%10得到当前n的个位，然后n/=10后再%10即可得到最低位被删除后的n的个位，即十位，这样循环即可得到数字各位的和。 函数代码如下：</p>
<p>int get_sum(int n){<br>    int sum = 0;<br>    while(n){<br>        sum+=n%10;<br>        n/=10;<br>    }<br>    return sum;</p>
<p>最后在main函数中进行简单的输入输出处理就可以了，ac代码如下：</p>
<p>#include<iostream></iostream></p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath></cmath></p>
<p>#include<cstring></cstring></p>
<p>#define N 1000001<br>using namespace std;<br>bool mark[N];<br>int arr[N];<br>int get_sum(int n){<br>    int sum = 0;<br>    while(n){<br>        sum+=n%10;<br>        n/=10;<br>    }<br>    return sum;</p>
<p>}<br>void get_prime(int n){<br>    int m = sqrt(n+0.5);<br>    memset(mark,0,sizeof(mark));<br>    for(int i = 2; i &lt;= m; i++){<br>        if(!mark[i]){<br>            for(int j = i*i; j &lt;= n; j+=i){<br>                mark[j] = 1;<br>            }<br>        }<br>    }<br>}<br>void get_arr(){<br>    int sum = 0;<br>    for(int i = 2; i &lt;= N; i++){<br>        if(!mark[i] &amp;&amp; !mark[get_sum(i)]){<br>            sum++;<br>        }<br>        arr[i] = sum;<br>    }<br>}<br>int main(){<br>    get_prime(N);<br>    get_arr();<br>    int n;<br>    cin&gt;&gt;n;<br>    int a, b, kase = 0;<br>    while(n–){<br>        scanf(“%d%d”, &amp;a, &amp;b);<br>        printf(“Case #%d: %d\n”,++kase,arr[b]-arr[a-1]);<br>    }<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/17/hdu2553-n-queen-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/17/hdu2553-n-queen-problem/" itemprop="url">Hdu2553 N皇后问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-17T22:28:09+08:00">
                2016-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/" itemprop="url" rel="index">
                    <span itemprop="name">A题</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>HDU 2553 N皇后问题</strong> <strong>Problem Description</strong> 在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。 你的任务是，对于给定的N，求出有多少种合法的放置方法。 <strong>Input</strong> 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 <strong>Output</strong> 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 <strong>Sample Input</strong> 1 8 5 0 <strong>Sample Output</strong> 1 92 10 题目就是裸的N皇后问题，思路就是带剪枝的回溯。可以理解为对其解答树进行dfs。 首先将题目简化为每行放置一个皇后，具体皇后列位置用C数组储存。则其生成的解答树有N！个结点，与全排列的生成一样。 然后具体递归时，注意在尝试时加入对皇后是否能攻击之前以放置的皇后进行检查，和全排列时检查与已放入元素是否冲突是一致的。这里用白皮书上的方法来具体实现，即用一个二维数组vis来标记是否冲突从而避免冲突的计算。 可以观察到每个格子的x-y值标识了主对角线，y+x值标识了副对角线，又这里cur为当前行x，i为当前列y,则cur+i即标识副对角线，如果vis[1][cur+i]=1,则表明该条对角线已被占用。又因为x-y可能为负数，所以这里取cur-i+n,即可保证祝对角线的索引为正。那么当相应主对角线被占用时，有vis[2][cur-i+n]=1. 最后用vis[0][i]标识当前列被占用（因为是逐行向下递归，所以行不可能冲突)即可完成对是否冲突的判断。 另外注意dfs的时候，每次回溯记得将全局标记变量还原,以便遍历列i取值的循环下一次运行到这里时，能够继续进入相应i的子树继而再次搜索下去。 这道题还要注意数据量较大，且很多重复，所以需要将第一次算出的数据存储一下，下一次询问时直接将已算出的数据打表出来即可。好像有大神用位运算也可以过，大家有兴趣可以试一下~ ac代码：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring><br>using namespace std;<br>bool vis[3][22];<br>int C[12];<br>int n,cnt;<br>int ans[11];<br>void search(int cur){<br>    if(cur==n){<br>        cnt++;<br>    }<br>    else for(int i=0;i&lt;n;i++){<br>        if(!vis[0][i]&amp;&amp;!vis[1][cur+i]&amp;&amp;!vis[2][cur-i+n]){<br>            C[cur]=i;;<br>            vis[0][i]=vis[1][cur+i]=vis[2][cur-i+n]=1;<br>            search(cur+1);<br>            vis[0][i]=vis[1][cur+i]=vis[2][cur-i+n]=0;<br>        }<br>    }<br>}<br>int main(){<br>    memset(ans,-1,sizeof(ans));<br>    while(~scanf(“%d”,&amp;n)&amp;&amp;n){<br>        if(ans[n]!=-1){<br>            printf(“%d\n”,ans[n]);<br>        }<br>        else{<br>            memset(vis,0,sizeof(vis));<br>            cnt=0;<br>            search(0);<br>            ans[n]=cnt;<br>            printf(“%d\n”,cnt);<br>        }<br>    }<br>}</cstring></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/17/generate-permutation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/17/generate-permutation/" itemprop="url">生成全排列</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-17T14:52:47+08:00">
                2016-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/回溯/算法学习/" itemprop="url" rel="index">
                    <span itemprop="name">算法学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1. <strong>按字典序生成1~n的全排列</strong> 思路：递归生成，建立一个数组A来存生成的全排列，然后在递归函数内部循环中，从小到大依次向A[cur]中填入一个之前未曾出现的整数i，然后当前位置cur+1并进入下一层递归。 递归边界是当前位置cur==n的时候，输出A数组，即为此种情况下的一个排列。 测试代码如下：</p>
<p>#include<cstdio><br>using namespace std;<br>void printf_permutation(int n,int *A,int cur){<br>    if(cur==n){<br>        for(int i=0;i&lt;n;i++){<br>            printf(“%d”,A[i]);<br>        }<br>        printf(“\n”);<br>    }<br>    else for(int i=1;i&lt;=n;i++){<br>        int ok=1;<br>        for(int j=0;j&lt;cur;j++){<br>            if(A[j]==i) ok=0;<br>        }<br>        if(ok){<br>            A[cur]=i;<br>            printf_permutation(n,A,cur+1);<br>        }<br>    }<br>}<br>int main(){<br>    int A[5]={0};<br>    printf_permutation(3,A,0);</cstdio></p>
<p>}</p>
<p>测试输出如下：</p>
<p>123<br>132<br>213<br>231<br>312<br>321</p>
<p>这个递归的特点在于for循环里递归，可以结合输出理解。 <strong>2.生成可重复集的排列</strong> 目标：输入数组P,按字典序生成数组P各元素的全排列。 思路，把生成1到n全排列的代码进行修改，A[j]==i改为A[j]==P[i],A[cur]=i改为A[cur]=P[i],每次输入P后，将P进行升序排列，然后调用递归即可。 注意：当输入数组有重复时，要在递归中进行判断，如果递归中该元素已重复次数小于原始数组中重复数组，则可以选择将其添加。这儿可以简单的用两个循环分别遍历当前A和P计数实现。 同时应该注意排序后的P数组，第i个元素和上一个元素相同时，就不用再取了，因为我们只要不遗漏不重复的取出P中所有数值即可，重数的问题在取数循环的内部已经解决了。这里可以在取数循环后加一句 if(!i||P[i]!=P[i-1]) 实现，第一个!i保证i为0时直接短路为真，而不执行后面越界的代码。 测试代码如下：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<iostream></iostream></p>
<p>#include<algorithm><br>using namespace std;<br>void printf_permutation(int n,int *A,int cur,int *P){<br>    if(cur==n){<br>        for(int i=0;i&lt;n;i++){<br>            printf(“%d”,A[i]);<br>        }<br>        printf(“\n”);<br>    }<br>    else for(int i=0;i&lt;n;i++){<br>        if(!i||P[i]!=P[i-1]){<br>            int c1=0;<br>            int c2=0;<br>            for(int j=0;j&lt;cur;j++){<br>                if(A[j]==P[i]){<br>                    c1++;<br>                }<br>            }<br>            for(int j=0;j&lt;n;j++){<br>                if(P[i]==P[j]){<br>                    c2++;<br>                }<br>            }<br>            if(c1&lt;c2){<br>                A[cur]=P[i];<br>                printf_permutation(n,A,cur+1,P);<br>            }<br>        }<br>    }<br>}<br>int main(){<br>    int A[99]={0};<br>    int P[99]={0};<br>    int n;<br>    cin&gt;&gt;n;<br>    for(int i=0;i&lt;n;i++){<br>        cin&gt;&gt;P[i];<br>    }<br>    sort(P,P+n);<br>    printf_permutation(n,A,0,P);</algorithm></p>
<p>}</p>
<p><strong>3.使用C++的STL库函数生成全排列</strong> C++的stl中自带了一个next_permutation 可以实现成字典序最小开始，快速的求下一个排练，从而得到全排列，且适用于可重集合。 测试代码如下：</p>
<p>#include<iostream></iostream></p>
<p>#include<algorithm><br>using namespace std;<br>int main(){<br>    int n,p[99];<br>    cin&gt;&gt;n;<br>    for(int i=0;i&lt;n;i++){<br>        cin&gt;&gt;p[i];<br>    }<br>    sort(p,p+n);<br>    do{<br>        for(int i=0;i&lt;n;i++){<br>            cout&lt;&lt;p[i];<br>        }<br>        cout&lt;&lt;endl;<br>    }while(next_permutation(p,p+n));<br>    return 0;<br>}</algorithm></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/17/uva10976-fractions-again/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/17/uva10976-fractions-again/" itemprop="url">Uva10976 Fractions Again?!</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-17T13:58:44+08:00">
                2016-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva10976 Fractions Again?!</strong> It is easy to see that for every fraction in the form 1 k (k &gt; 0), we can always find two positive integers x and y, x ≥ y, such that: 1 k = 1 x + 1 y Now our question is: can you write a program that counts how many such pairs of x and y there are for any given k? <strong>Input</strong> Input contains no more than 100 lines, each giving a value of k (0 &lt; k ≤ 10000). <strong>Output</strong> For each k, output the number of corresponding (x, y) pairs, followed by a sorted list of the values of x and y, as shown in the sample output. <strong>Sample Input</strong> 2 12 <strong>Sample Output</strong> 2 1/2 = 1/6 + 1/3 1/2 = 1/4 + 1/4 8 1/12 = 1/156 + 1/13 1/12 = 1/84 + 1/14 1/12 = 1/60 + 1/15 1/12 = 1/48 + 1/16 1/12 = 1/36 + 1/18 1/12 = 1/30 + 1/20 1/12 = 1/28 + 1/21 1/12 = 1/24 + 1/24 这道题关键在于缩小枚举范围，因为x&gt;=y，又1/k=1/x+1/y,代入得y&lt;=2*k. 注意到x,y 均为正整数，则有y&gt;=k+1，这样只用枚举10000次y，即可在符合条件时通过y反解出x，得到答案。 在判断是否符合条件时，直接看是否整除即可，如果整除，则把商赋给x. 注意题目要求先输出解的数量，再按序输出解，所以这里用vector存了x,y的解，输出时先输出vector的size再对应输出x,y即可 ac代码如下：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<vector><br>using namespace std;<br>int main(){<br>    int k;<br>    vector<int> xx,yy;<br>    while(~scanf(“%d”,&amp;k)){<br>        for(int y=k+1;y&lt;=2<em>k;y++){<br>            if(k</em>y%(y-k)==0){<br>                xx.push_back(k*y/(y-k));<br>                yy.push_back(y);<br>            }<br>        }<br>        int cnt=xx.size();<br>        printf(“%d\n”,cnt);<br>        for(int i=0;i&lt;cnt;i++){<br>            printf(“1/%d = 1/%d + 1/%d\n”,k,xx[i],yy[i]);<br>        }<br>        xx.clear();<br>        yy.clear();<br>    }<br>    return 0;<br>}</int></vector></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/17/uva11059-maximum-product/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/17/uva11059-maximum-product/" itemprop="url">Uva11059 Maximum Product</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-17T13:20:48+08:00">
                2016-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva11059 Maximum Product</strong> Given a sequence of integers S = {S1, S2, . . . , Sn}, you should determine what is the value of the maximum positive product involving consecutive terms of S. If you cannot find a positive sequence, you should consider 0 as the value of the maximum product. <strong>Input</strong> Each test case starts with 1 ≤ N ≤ 18, the number of elements in a sequence. Each element Si is an integer such that ?10 ≤ Si ≤ 10. Next line will have N integers, representing the value of each element in the sequence. There is a blank line after each test case. The input is terminated by end of file (EOF). <strong>Output</strong> For each test case you must print the message: ‘Case #M: The maximum product is P.’, where M is the number of the test case, starting from 1, and P is the value of the maximum product. After each test case you must print a blank line. <strong>Sample Input</strong> 3 2 4 -3 5 2 5 -1 2 -1 <strong>Sample Output</strong> Case #1: The maximum product is 8. Case #2: The maximum product is 20. 题意：寻找乘积最大的连续子序列 由于只有18个整数，直接完全枚举即可。 注意输出的时候要%lld,因为绝对值不超过10且不超过18个数，则最大乘积不超过10^18，在long long 10^19的范围内，所以可用long long 储存答案并用lld输出 ac代码如下</p>
<p>#include<cstdio><br>using namespace std;<br>int main(){<br>    int n;<br>    int s[20];<br>    int kase=0;<br>    while(~scanf(“%d”,&amp;n)){<br>        for(int i=0;i&lt;n;i++){<br>            scanf(“%d”,&amp;s[i]);<br>        }<br>        long long max=0;<br>        for(int i=0;i&lt;n;i++){<br>            long long ans=1;<br>            for(int j=i;j&lt;n;j++){<br>                ans*=s[j];<br>                if(ans&gt;max){<br>                    max=ans;<br>                }<br>            }<br>        }<br>        printf(“Case #%d: The maximum product is %lld.\n\n”,++kase,max);<br>    }<br>    return 0;<br>}</cstdio></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/17/e5-b8-b8-e7-94-a8-e6-95-b0-e6-8d-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/17/e5-b8-b8-e7-94-a8-e6-95-b0-e6-8d-ae/" itemprop="url">常用数据</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-17T12:18:20+08:00">
                2016-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/未分类/" itemprop="url" rel="index">
                    <span itemprop="name">未分类</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>long long 9.2*10^19</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Fan Yijie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fan31415" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fanyije@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fan Yijie</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
