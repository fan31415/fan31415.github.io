<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo-32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo-16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.ong?v=5.1.4" color="#222">





  <meta name="keywords" content="fanyijie, technology" />










<meta property="og:type" content="website">
<meta property="og:title" content="Fan&#39;s Home">
<meta property="og:url" content="https://fanyijie.net/page/2/index.html">
<meta property="og:site_name" content="Fan&#39;s Home">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fan&#39;s Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanyijie.net/page/2/"/>





  <title>Fan's Home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fan's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2017/09/19/compile-theory-syntactic-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/compile-theory-syntactic-analysis/" itemprop="url">编译原理总结-语法分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-19T13:08:18+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术分享/" itemprop="url" rel="index">
                    <span itemprop="name">技术分享</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="输入输出的具体处理"><a href="#输入输出的具体处理" class="headerlink" title="输入输出的具体处理"></a>输入输出的具体处理</h4><p><em>i 输入</em> 这里的输入实际上仅仅是一个tokens数组而已，很好处理，只需要读入xml，然后找到tokens这个XML项，然后对其子节点依次解析，将每个filed存入我们临时创建的一个token中，再对每一个子节点将这个临时token加入tokens数组容器即可，类似于反序列化的过程。具体实现可以在input函数中查看。 <em>ii 输出</em> 这儿我们首先明确输出对象是一颗语法分析树，所以我们需要一个多叉树的数据结构来存储这个输出结果。这里由于采用了jdom库作为xml输出，其中已经有了一个Element类型可以作为多叉树的节点使用（XML文件本身就是具有多叉树形式的）， 所以我就直接借用了jdom的Element类型作为我们语法分析树的节点类型。在这里整个输出流程就被划分为了构造和真正输出两部分。 事实上这儿也有两种策略选择，一种方式是只进行简单的构造，例如将语法树的元素直接add进一个数组并做一些结构化的标记，然后在输出时再通过较为复杂的方式将结果重新组织为语法树的形式输出。也可以在构造时直接构造为一颗完整的树，输出时直接从树的根节点开始顺序输出就行了。 正如之前所说，由于我采用了jdom的Element类型作为节点类型，所以显然最简单的方式就是在我进行语法分析时同时构造一颗完整的语法树，这样最后直接将整个语法树的根节点调用jdom库的标准输出就可以了。</p>
<h4 id="具体实现策略的选择"><a href="#具体实现策略的选择" class="headerlink" title="具体实现策略的选择"></a>具体实现策略的选择</h4><p>语法分析器一般有两种大的设计思路：自顶向下设计和自底向上设计。 自顶向下设计也被称为预测性语法分析，它从语法分析树的树根开始，系统化的向下扩展树，直至树的叶结点与词法分析器返回的已归类单词匹配。它的特点是紧凑而高效。可以用递归下降或是LL（1）（表驱动或直接编码的）来实现。并且因为在语法分析过程中的每一点，这种语法分析器都知道可以作为有效输入串中下一个符号出现的单词集，因而可以产生精确而有用的错误信息。它的主要缺点在于无法处理左递归，与右递归相比，左递归文法用一种更自然的方式建立了表达式运算符从左到右的结合性的模型。至于回溯方面，由于大多数程序语言结构都可以用无回溯语法表达，所以在这一点上对自顶向下分析的应用影响不大。 自底向上分析是指从叶结点开始构建语法树，自叶结点向根节点方向进行的分析方法。语法分析器对词法分析器返回的每个单词分别构建一个叶节点，这些叶结点形成了语法分析树的下边缘。为了构建一个推导，语法分析器需要根据语法和语法分析树完成的底部，在叶结点之上添加非终结层。它的语言适应范围比自顶向下更广，即使是左递归文法和左公因子的文法也能正确处理。通常使用表驱动的LR（1）语法分析来实现。 这里由于我们的文法较为简单，而且在设计的时候已经消除了左递归和左公因子，所以非常适合自顶向下的语法分析器。并且一个构建良好的递归下降语法分析器可以比表驱动的LR（1）语法分析器更加迅速，所以我选择了递归下降的方法来实现语法分析器。尽管LR（1）的直接编码方案可以胜过递归下降，但是考虑到自顶向下的递归下降语法分析器是最容易以手工编码的方式构建的，所以还是没有采用直接编码的LR（1）。此外，递归下降语法分析器相比LR（1）在错误处理方面更有优势，并且更容易处理语言中的二义性。 这里我们通过检查前瞻符号和First集合来消除自顶向下分析中产生式子的不确定性，这样就可以避免递归中的回溯。整个策略就是对于文法每一个非终结符，我们构建一个函数来识别与之匹配的各个产生式的右侧句型。这些过程按照设计的文法规则彼此嵌套调用，以识别对应的非终结符。终结符的识别在这里为了便于输出，通过简单的匹配函数进行。</p>
<h4 id="非终结符识别函数的设计"><a href="#非终结符识别函数的设计" class="headerlink" title="非终结符识别函数的设计"></a>非终结符识别函数的设计</h4><p>对于递归下降函数，最关键的部分就是程序的主体———非终结符识别函数的设计了。首先要考虑的是函数返回的设计。因为在识别的过程中，尽管这里已经消除了回溯再识别的情况，但是仍然难以避免存在识别失败的情况。这时有两种解决方案，一种是直接在最底层报告错误然后结束程序，另一种是逐层上报，在适当的分析层上报告相应信息并尝试恢复或者停止分析。这里我因为一开始想检测文法是非为回溯文法，以及想进行一些错误恢复工作而选择了后者。这样的话，每个函数必须有一个布尔型的返回值来指示其解析是否成功。 除了返回值，函数的参数也是需要考虑的一个点。这里同样有两种选择方案。一种是保持为空，然后依靠输出一些结构性语句来在线性的数组中维持一个树的结构。另一种是直接传入父节点，然后如果识别成功就把在当前识别函数中新建的节点加入到父节点中。这里采用了后者来实现，因为这样先构建一颗完整的语法树再直接输出的方式更为直接，而且实现更加简洁。为了避免代码重复，这儿我把成功识别并加入父节点的逻辑和返回值的操作进行了合并，合并到了一个succ()函数中。而对于空节点和失败识别的操作也做了类似的处理，分别对应程序中的pushNull()和fail()函数。其中fail()函数中还包含了错误处理的逻辑。 此外就是整个token数组指针的移动问题，为了得到一个更清晰的逻辑，这里将指针移动都放入了识别终结符的匹配函数中，因为识别非终结符本身是不需要移动指针的，构建过程只是在上层完成，只有对叶子上终结符的识别完成，才会需要移动指针。将这个操作封装进匹配函数而不是裸露在非终结符的识别函数中，可以保持实现的简洁和逻辑的清晰，在函数中只需要按照文法依次调用即可。 对于token数组指针移动，还有一个先后问题。这里选择了只有匹配成功才移动，如果失败时不会移动。对于识别的时候也是，只有识别成功的时候才会加入父节点，不然就不会操作。这样做主要是避免了潜在的回退或者删除节点的操作，提高了效率，实现上也更加简洁。 另外，对于文法中存在“||”或的地方，我们需要对下一个token和first集进行匹配检查，以确定应该进入或的哪一项，或是匹配失败。这里我建立一组单独的检查函数来进行。它和终结符的匹配函数的区别主要在于检查函数的调用不会引起token数组指针的移动。 例如下图即为实现while语句识别的函数，为了便于修改保留了if的所有大括号。 下图是识别statement list的函数，其中可以看到提前对空集情况的first集进行了判断，从而避免了回溯。</p>
<h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p>根据上述思考的结果，我将语法分析器的函数分为了流程函数，控制函数，终结符匹配函数，检查函数，非终极符识别函数，输入输出函数以及一些为了代码重用而实现的辅助类函数。 流程函数类似于主函数，在其中依次调用输入函数，初始化函数，分析树根节点的识别函数，输出函数。 输入输出函数则简单的完成自己的输入输出基本逻辑即可，其中没有业务逻辑。 控制函数这里其实就是next()函数，负责取下一个token以及潜在的避免越界的限制。 终结符匹配函数是负责直接匹配终结符的，它同样以父节点为参数，如果识别成功该终结符，它将新建这个终结符的节点并把终结符的value设置进节点的text域中，再把该节点加入到父节点中，并前进一个token指针。如果识别失败，则直接返回fail()。 检查函数则是为了检查当前token和first集是否一致的，一致则返回true，不一致则返回false。它是为了在识别非终结符中避免回溯服务的。</p>
<h4 id="文法设计"><a href="#文法设计" class="headerlink" title="文法设计"></a>文法设计</h4><p>根据前面的分析，整个语法分析器的骨架已经有了，现在给出文法设计来填充这个分析器。事实上文法设计我是第一步做的，因为语法分析器的设计本身就是基于文法的，如果没有确定文法，那么具体架构的设计也就无从得知了。 这里我设计的文法涵盖了局部变量声明，赋值语句，返回语句，if语句，if-else语句，while循环语句，更多的文法由于时间原因尚未实现，就先去除了。这里采用了ANTLRWorks的格式书写, 冒号：代表语法右部开始，竖线| 代表或，分号；代表一个文法项的结束，括号（）表示了优先级。 <code>CMPC_UNIT:FUNC_LIST; FUNC_LIST:FUNC_DEF FUNC_LIST|; FUNC_DEF:TYPE_SPEC ID &#39;(&#39;PARG_LIST&#39;)&#39; &#39;{&#39;STMT_LIST’}’; FUNC_TYPE: TYPE|’void’; TYPE_SPEC: ‘int’|’float’|’char’|’double’; PARG_LIST:(TYPE_SPEC ID (’,’PARG_LIST)|)|; STMT_LIST:(STMT STMT_LIST)|; STMT:RTN_STMT|ASSIGN_STMT|WHILE_STMT|BRANCH_STMT|DECLARE_STMT; RTN_STMT:&#39;return&#39; EXPR ‘;’; DECLARE_STMT: TYPE_SPEC ID ID_LIST ’;’; ID_LIST: (‘,’ ID ID_LIST) |; ASSIAN_STMT:TYPE_SPEC|ε ID&#39;=&#39;EXPR ‘;’; EXPR:TERM EXPR2; EXPR2:(&#39;+&#39; TERM EXPR2)|(&#39;-&#39; TERM EXPR2)|; TERM:FACTOR TERM2; TERM2:(&#39;*&#39; FACTOR TERM2)|(&#39;/&#39; FACTOR TERM2)|; FACTOR:ID|CONST|(&#39;(&#39;EXPR&#39;)&#39;); WHILE_STMT:&#39;while’’(‘JU_STMT&#39;)&#39;&#39;{&#39;STMT_LIST&#39;}&#39;; BRANCH_stmt:’if’ ‘(‘JU_STMT’)’ ‘{‘stmt list’}’ (else ‘{‘stmtList’}’ )|; JU_STMT:FACTOR (JUDGE_OP FACTOR)|; JUDEG_OP:’&lt;‘|’&gt;’|’&lt;=‘|’&gt;=‘; ID: (&#39;a&#39;..&#39;z&#39;|&#39;A&#39;..&#39;Z&#39;)+ (&#39;a&#39;..&#39;z&#39;|&#39;A&#39;..&#39;Z&#39;| &#39;0&#39;..&#39;9&#39;)* CONST:( ‘0’..’9’)*</code> 经过检查可以发现，该文法没有左递归和左公因子，可以直接用于递归下降语法分析器。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>选用递归下降的一个原因就是用它可以方便的进行错误处理。这里对于错误处理主要由两种措施，一是报告错误，二是修正错误。这里选取第一种方式，也是更加常见的方式。此外，还有两种处理策略，一是遇到错误就停止，二是继续尝试分析。明显第二种方式更好，因为程序员编写程序过程中可能会有多个错误，通过第二种方式能够发现在一次编译中发现更多的错误。 因此我们需要建立一种机制，使得语法分析器能够从错误中恢复，转移到另一个状态，从而继续进行语法分析。这种机制通常是选择一个或多个单词作为同步词，每当遇到一个错误时，它将不断丢弃单词直到找到一个同步词，然后从这个同步词一致的状态继续开始分析。 在本程序的递归下降中，只需要遇到错误时不断丢弃token，直到遇到分号为止。此时语法分析器将控制转移到解析语句例程报告成功的位置。这里由于时间关系暂时只实现了在合适的位置报告解析错误的位置以及相应的单词的错误处理，但是已经预留了相应的接口为之后的改进做准备。毕竟如果使用一个一次编译只能发现一个错误的编译器来编译，那真的会是一个冗长而费力的过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2017/09/19/compile-theory-lexical-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/compile-theory-lexical-analysis/" itemprop="url">编译原理总结-词法分析</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-19T13:06:08+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术分享/" itemprop="url" rel="index">
                    <span itemprop="name">技术分享</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="输入输出的具体处理"><a href="#输入输出的具体处理" class="headerlink" title="输入输出的具体处理"></a>输入输出的具体处理</h4><p><em>i 输入</em> 这里采用了双缓存来作为基本的输入模式。即先读入一定量的字符到某一缓存中，每当将要访问到这一缓存尽头时，就提前读入下一缓存，这样交替循环。其思想和计算机图像学中的双缓存是一致的，都是为了在内存有限的前提下，保证运行的连续性。支撑这种模式的根本原因应该是cpu处理和IO处理速度的不一致性。由于CPU速度远远大于IO，而这里处理单个字符的时间复杂度又是O（1）的一个小数量级，所以IO是这一类程序运行的主要瓶颈。这里通过double buffer的策略，就很好的平衡了IO与CPU速度的差距，同时保证了内存的消耗不会过大。但是这里要注意一点，就是单个缓存区不能开的过小，不然频繁的IO将对整个系统的运行产生灾难性的影响。查阅相关文献可以发现，如果缓冲区的大小设定有着较强的敏感性，过低或过高，都将对速度以及内存消耗产生剧烈的影响。 不过我们这儿由于测试过程中读入的程序文件都较小，且计算机的内存较大，所以影响还不够明显，暂时设定为一个文献参考值8000 char作为我们的基准。 在具体实现方面，由于采用了双缓存策略，每次都将从上一次读入结束的位置开始读入一个固定的量，所以这里采用了BufferReader和InputSteamReader结合的方式来实现这样的读取。通过BufferReader的skip函数即可实现我们想要的功能。 <em>ii 输出</em> 这里直接使用了jdom库作为xml输出，这里建立一个Token的java bean作为输出的对象。在ouput方法中遍历Token的Array即可实现，这个地方较为简单，就略过了。</p>
<h4 id="具体实现策略的选择"><a href="#具体实现策略的选择" class="headerlink" title="具体实现策略的选择"></a>具体实现策略的选择</h4><p>词法分析器一般有三种实现方法，一是通过第三方库自动生成，比如lexAnalysis等已经比较成熟的三方库都可以，他们往往是表驱动的。当然也可以直接写一个转移表来实现。但是这样生成的词法分析器在性能上往往有所欠缺。更进一步就是直接编码，通过代码上的跳转来代替查表的开销。但是这样写出的代码往往可读性比较差，不利于后面的维护与修改。 这里我采用了基于while循环和switch语句的手工编码策略。在最大化性能与高灵活性的前提下，尽量提高了代码的可读性。当然也有缺点，那就是大量的case与if else，以及繁复的思考过程。要实现C11的标准，事实上还需要更多的考量，因为c语言编译器的各个步骤不是完全分开的，它还有很多的编译选项（CPP_OPTION），这个由于框架的局限性暂时无法完全实现。不过对于核心的语法部分，还是可以通过合理的安排case较好的实现的。 之所以选择switch作为主要分支而不是if else，主要是基于两方面的考虑。 一是从汇编的角度考虑，面对大量的分支，switch是优于if else的，因为在底层可以通过一个转移表来实现一次性转移，而节省了大量的cmp或者test的开销。 二是从可读性的角度考虑，面对大量分支，case往往比if’ else更加清晰。 除此之外，由于是手工编码，并且采用双缓存模式，所以可以不需要逐字的循环，每一次循环都表示一个单词处理的完成。这样整个效率也可以得到较大的提升。 另外为了降低耦合度，使整个代码更加清晰，参考了一些成熟开源编译器的做法，对于每一种类型具体的识别和处理，我分别采用了单独的函数进行更加细致和具体的处理，其中包括了Token的填充逻辑。</p>
<h4 id="关键字的识别"><a href="#关键字的识别" class="headerlink" title="关键字的识别"></a>关键字的识别</h4><p>关键字的识别无疑也是一个重点。对于手动编码来说，如果要将关键字的识别与标识符的识别提到同等地位，这是有点难以接受的。因为即使你用switch为主导来实现，这也是基于背后隐含的自动机转移而实现的。如果加入了整体关键字，那整个状态数将会急剧的增长，而且如果你在日后想要更新关键字，不管是增加还是删除，都需要再一次的计算整个自动机。 所以基于状态数的控制以及可维护性这两方面，我决定将关键字作为标识符的二次判断来进行。即先识别是否是标识符，如果的确是标识符的话，再识别其是否是关键字。 这里对于最后的判断是否是关键字，处于性能上的考虑，我采取了hash的策略。即在程序设计之初，就把关键字全部储存为其hash值，而不需要存储关键字本身。在词法分析的时候，也只需要将当前单词的hash值与存储的hash值比较即可。这样做的原因是因为比较两个整数是否相等对于计算机只需要一个机器码即可，而比较字符串的相等的消耗就要大得多了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2017/09/19/compile-theory-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/compile-theory-summary/" itemprop="url">编译原理总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-19T13:04:28+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术分享/" itemprop="url" rel="index">
                    <span itemprop="name">技术分享</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Simple-C-Complier是一个C语言子集的编译器。编译器的实现目标是读入C语言子集的源码文件，编译生成 MIPS汇编代码。限于课堂实验要求，采用了bit-minic-compiler框架作为输入输出限定，实际不需要框架也能直接运行。</p>
<h4 id="0x0-实现语言的选择"><a href="#0x0-实现语言的选择" class="headerlink" title="0x0 实现语言的选择"></a>0x0 实现语言的选择</h4><p>对于用什么语言实现，我进行了一些考虑。首先根据框架需求，在不对框架代码进行改动的前提下，这儿有python，C，C++， 以及java这四种语言可选。 下面对这四种语言的优劣进行了分析</p>
<p>语言</p>
<p>运行速度</p>
<p>实现速度</p>
<p>是否面向对象</p>
<p>是否支持GC</p>
<p>其他缺点</p>
<p>其他优点</p>
<p>C</p>
<p>快</p>
<p>较慢</p>
<p>否</p>
<p>否</p>
<p>字符串处理较弱</p>
<p>可以自举</p>
<p>C++</p>
<p>快</p>
<p>较慢</p>
<p>是</p>
<p>否</p>
<p>Python</p>
<p>慢</p>
<p>快</p>
<p>是</p>
<p>是</p>
<p>需要额外python模块才可以运行，而且有2与3的版本问题</p>
<p>函数丰富，实现迅速</p>
<p>Java</p>
<p>一般</p>
<p>较快</p>
<p>是</p>
<p>是</p>
<p>代码量较大，不够优雅</p>
<p>函数丰富，实现较快，与框架语言一致，便于扩展</p>
<p>那么到底选哪一种语言呢，除了语言本身特点，我们还必须考虑一点，那就是我们对语法分析器本身的需求。这里我主要的目标是在于学习实践，所以经过再三考虑，选择了java语言作为实现语言。因为这样可以快速实现，快速修改，无需担心GC的烦恼，也无需关心过多字符串的处理，文件的输入与生成等一系列外围的问题，可以专心考虑最核心的逻辑。当然还有一点就是，限定的输入输出框架已经使用java语言实现了，这里就直接统一使用java了。</p>
<h4 id="0x1-总体架构"><a href="#0x1-总体架构" class="headerlink" title="0x1 总体架构"></a>0x1 总体架构</h4><p>这里按照框架要求，采用了分离的结构。 首先是预处理pp模块读入c文件，预处理后输出pp文件；然后词法分析scanner模块读入pp文件，输出token文件，然后语法分析parser模块读入token文件，输出tree文件；然后语义分析semantic模块读入tree文件，生成tree2文件；接着中间代码生成模块icgen读入tree2文件，生成ic文件；然后优化optimizing模块读入ic文件，生成ic2文件；然后代码生成模块codegen读取ic2文件，生成mips代码，最后调用mars模拟器运行mips汇编代码。整体流程图如下 <img src="http://fanyijie.net/wp-content/uploads/2017/09/编译流程-533x1024.jpg" alt=""></p>
<h4 id="0x2-项目导航"><a href="#0x2-项目导航" class="headerlink" title="0x2 项目导航"></a>0x2 项目导航</h4><p>这儿限于课程时间，实现了其中最关键的四个模块，分别是词法分析，语法分析，语义分析和代码生成，其中语义分析和代码生成整合在了一起进行。项目完成后对于需求中的C语言的子集进行了测试，成功生成了对应的MIPS汇编代码。下面将分篇对这四个模块的实现分别阐述。分节链接如下： <a href="http://fanyijie.net/compile-theory-lexical-analysis">编译原理总结-词法分析</a> <a href="http://fanyijie.net/compile-theory-syntactic-analysis">编译原理总结-语法分析</a> <a href="http://fanyijie.net/compile-theory-semantic-analysis-and-code-generation">编译原理总结-语义分析与代码生成</a> 具体项目代码见<a href="https://github.com/fan31415/Simple-C-Complier" target="_blank" rel="noopener">github</a>.</p>
<h4 id="0x3-实现中的不足"><a href="#0x3-实现中的不足" class="headerlink" title="0x3 实现中的不足"></a>0x3 实现中的不足</h4><p>1） 由于采用了java语言实现，所以最后的运行速度肯定是不如可以面向底层优化的C语言的。在效率上就有差别，而且很多地方明显可以使用汇编进行进一步的优化，或者使用宏编译，虽然牺牲了可读性，但是对于效率可以有一个较好的常数级提升，如果要作为商业使用的编译器，这一点还是值得的。除此之外，还尤其体现在文件的IO，以及内存控制上。一切事物都具有两面性，在享受java便捷的IO时，也不得不承认相比更加底层的C语言IO机制，在速度上是有所欠缺的；在享受java面向对象的便捷特性时，也必须承认，对象创建的开销，是过程式语言所可以避免的；在享受java自带GC的优点时，我也不得不说，对于内存控制上，自带的GC还是不如手动释放精细节约的，这是因为java本身gc机制所带来的局限性，也是无法避免的。这也让我想到了android和ios的差别，所谓开放的越多，你越自由，控制越精细，调教的越好，但是烦恼也越多；而限制越大，你的选择更少，但是你也更轻松，更可以专注你要做的核心。这也是一种取舍吧。只能说，根据你的目标，去找到你自己的平衡吧。 2） 整个实现还是优化不足，比如有的地方为了可读性而重复了一些前进和回滚的操作，这个如果更加精细化的实现，是可以避免一部分回退的。 3） 这一点也是由于框架的局限性，对于很多地方事实上在词法分析阶段就可以做的，这里没有做。比如说对于不同的operator，事实上是可以直接将其具体类别，比如plus, minus作为其最终类型的。只需要将所有的类型进行细分，然后enum出来，就可以通过一个enum的整数很快捷的标志出其具体类型，这样可以对之后的步骤提供帮助。再比如对于一些数值型的东西，事实上可以再词法分析时，一遍过时就将其数值以Int这样的形式保存下来，并且直接传递给下一步，这样也可以节约一些时间。当然这样就不能通过xml的形式传递了，而是将词法分析和语法分析结合在了一起，直接在内存中进行传递。这样明显效率更高，当然我们这个是教学框架，所以现在这样也是可以理解。不过这样的话还有一个缺陷，就是无法真正实现C11标准，因为C11标准中涵盖的东西大于了我们要输出的token文件，比如CPP_OPTION，以及对于宽型的支持，这样的内容需要将token文件进行进一步扩展。 4）由于时间关系，尽管为错误处理预留了位置，但是目前仍是一次编译只能发现一个错误的形式，没有实现一次编译检查出多处错误，这个是之后需要改进的一个重要地方。 5） 事实上，如果把词法分析和语法分析结合起来，以及后面的语义制导整合在一起，应该会有更好的表现。因为可以直接在内存之间传递很多表和数据，大大减少了IO时间。当然这样的不足就是耦合性也更强了。 6） 由于时间关系，寄存器的分配还有很多不完善的地方，事实上寄存器分配是一个很大的部分。如果我们的程序集需要引入更多更复杂的语言规则，我觉得有必要进行一趟处理来分配寄存器并将其指派为相应的值。这里面涉及到了很多策略，包括一些图着色的算法。这个是之后需要改进的一个重要地方。 7） 这里没有单独进行语义分析，事实上是有很多欠缺的。在实现中可以明显感觉到很多信息获取不够完全，导致面对复杂代码结构时手动解析比较麻烦，整个程序不是十分清晰，而且如果要进行代码优化以及引入更多的嵌套调用以及全局调用也会更加麻烦。如果要进一步完善编译器，语义分析这一步还是不能省略，而且由于之前的步骤中对函数调用以及全局变量没有做足够的处理，这次也没有涉及到这块的内容，这个也是之后亟待增加的。 8） 同样是由于没有语义分析，其中很多可以做的事情也没有做，比如类型检查，代码优化，这个是之后可以增加的地方。</p>
<h4 id="0x4-感想"><a href="#0x4-感想" class="headerlink" title="0x4 感想"></a>0x4 感想</h4><p>在实现编译器的过程引发我对程序语言本身以及语言设计的很多思考。比如为什么C语言结尾有分号，而Swift语言结尾不需要分号；为什么Java语言和C语言可以随意空格，而Python必须严格遵守缩进；函数式语言的lambda形式是怎么实现编译的；怎样才能实现JavaScript的递归式函数定义等等，也激发了我对编译原理研究的兴趣。这也是我第一次完成了一个小型的编译器，并在mips模拟器上成功运行。当然就向我前面所说，还有很多不足，语言的范围也很有限，希望之后有时间可以继续完善这个Simple-C-Compliler.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2017/05/09/experience-of-a-full-android-project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/09/experience-of-a-full-android-project/" itemprop="url">Android项目总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-09T14:00:42+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>前言：这篇文章写于2016年11月，这次分享在博客上希望能得到一些指正（ps：人呐就都不知道，自己就不可以预料，当初说好的继续研习java，怎么就去写swift了呢 … 另：wordpress上的markdown显示为什么这么难看啊= =)</em></p>
<h2 id="项目综述"><a href="#项目综述" class="headerlink" title="项目综述"></a>项目综述</h2><p>该项目是一个小型商业app项目，app目标受众为大学生，目前已在应用商店上架android，ios的测试版。笔者负责android版的独立开发，本文是对开发中经验与教训的总结，如果有什么问题和想要指出或者想和笔者探讨的，欢迎发送邮件到<a href="mailto:fan12356789@gmail.com" target="_blank" rel="noopener">fan12356789@gmail.com</a>。 项目主要采用java语言编写，代码量接近两万行，大概有70个左右的activity页面，采用了mvp框架开发，选用了okhttp，eventbus等主流开源类库，开发周期为两个月（业余时间开发），测试周期一个月。 团队配置为产品经理一人，UI设计师一人，测试一人，ios一人，android一人，后端开发一人，html开发一人。</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>一个项目的架构选择对于整个项目代码的设计都有很大的影响。android开常见等架构有mvc，mvp，mvvm。最初移动端开发还是沿用的之前最普遍的MVC架构，但是这样做一个弊端，就是由于android有一个activity类作为视图的展现类，绝大多数类也都围绕activity类展开，所以使用mvc很容易让activity类变得无比庞大（activity往往既充当view层又充当control层），从而不利于类的功能解耦，也对维护和进行单元测试造成了麻烦。所以引入了mvp这一概念，也就是将以前model层，view层，control层变为了model层，view 层，presenter层。这里的view是一个单独的接口，里面涵盖了一个acitivity所具体要进行的视图上的交互操作。而presenter层则类似于之前的control层的功能，将model层的数据在这儿进行转换处理，你可以将它看作一个model与view之间的adpter。presenter层最终将转换好的最终数据交给view层去具体显示在ui上。 大略来说，view层负责处理用户事件和视图部分的展示，他的具体实现在一个acitivity或者fragment里，但是应该将其操作抽象成接口以便修改和解除耦合。 model层负责访问数据，数据可能来自服务器api，也可能来自本地数据库，文件或者SharedPreference。 presenter层负责将低层的数据转换并提交给view层，是低层数据连接ui层的桥梁。 此外还可以加上一个业务逻辑层，位于model层和presenter层之间，以便进一步根据具体业务逻辑处理model层的原始数据。 具体数据流如下图 <img src="http://fanyijie.net/wp-content/uploads/2017/05/c81e728d9d4c2f636f067f89cc14862c2-300x226.png" alt="c81e728d9d4c2f636f067f89cc14862c2">enter层中mock数据分发给view层，来测试各种ui。而且acivity层也变得轻量化，职责也很明确，更不会出现业务逻辑和ui显示全部挤在acitivty中的情况。以及还可以进一步用fragment作为view层的载体，而acitivty仅仅作为创建view层（framgent）和presenter层的控制器。 而mvvm架构则不再有presenter层，取而代之的是一个viewmodel层，而且view和viewmodel之间是databinding的关系，也就是说当你改变viewmodel层的数据时，也会直接影响到view层的ui。</p>
<h3 id="架构总结"><a href="#架构总结" class="headerlink" title="架构总结"></a>架构总结</h3><p>总结起来，事实上各个架构都有自己的优缺点。</p>
<h4 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h4><p>每次view收到事件后，发送消息给control，control发送消息到model要求更新数据，model更新了直接发送给view显示 优点：</p>
<ul>
<li>开发较快，不需要维护较多的接口</li>
<li>思路直观，便于快速修改</li>
</ul>
<p>缺点：</p>
<ul>
<li>view层和model层直接耦合，不便于测试和维护</li>
<li>activity任务过于繁重，不利于代码review</li>
</ul>
<h4 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h4><p>view收到事件后，发送消息到presenter层，presenter层通知model层要求处理，model层处理后将数据返回给presenter，presenter再将数据返回给view层。 优点：</p>
<ul>
<li>利于测试</li>
<li>实现了view和model层的完全解耦</li>
<li>利于维护</li>
<li>减轻了activity的负担</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于需要维护较多的类和接口，对于小型app可能过于冗余，影响开发速度</li>
<li>修改时需要修改较多的类和接口，因为可能同时涉及到多个层次</li>
</ul>
<h4 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h4><p>优点：类似于mvp 缺点：view层还是过重，并且有时仍然需要将一些操作写到view 层里。</p>
<h3 id="架构选择"><a href="#架构选择" class="headerlink" title="架构选择"></a>架构选择</h3><p>综合考虑，由于开发阶段为单人开发，项目规模不太大，而且时间要求较紧，采用了mvp和mvc结合的方式进行架构设计。 具体就是对于典型的主要activity采用mvp架构进行开发，而大量的小页面activity则直接采用mvc模式开发，以达到速度和可测试可review性兼具。 此外，根据项目实际情况和便于管理的考虑，项目分为了以下的模块。api是项目中所用到api的集合管理，db是数据库的相关封装类，adpter为主要复用的各个adpter的集合，bean为项目通用实体类的包，event是evnentbus通信所可以公用的event以及一些event基类，model为业务层和数据获取层，调用数据库和api从中获取数据,utils包下封装了各个工具类和app级的常量类，module包下面时app组装实现app功能的各个模块。在各个模块内部继续划分到每个页面的小模块，对于小页面采用mvc结构，主要大页面采用mvp架构，行成一个包含presenter层，view接口的页面包。总体如下图所示 <img src="http://fanyijie.net/wp-content/uploads/2017/05/app_struct-300x69.png" alt="app_struct"> 考虑到方便模块化开发，页面ui对应，和总体组件复用和代码管理，最后采用了这样的程序架构。 优点在于根据ui所属模块，可以很容易在module中找到对应的小模块进行测试和修改，而通过小模块中的依赖关系又可以在各个app级的复用包中，很快找到相应的可能需要修改或者阅读的地方。对于小页面，代码量少，只需要将io与ui解耦即可，就没有做过多的处理。而大页面由于代码众多，所以使用mvp进行了适当的解耦，方便之后阅读和修改。 缺点在于，整个架构不如标准的mvp清晰，层次清楚。部分代码的层次比较混乱，而且只将io部分与activity进行了完全的解耦，对于其他的业务逻辑大量的混在ui展示中，尽管设计了总的activity接口和函数，以便每个activity借此将业务逻辑与业务逻辑，ui与ui，业务逻辑与ui相分开，但还是不够清晰，特别是在追求速度的过程中，很多地方的实现不够优雅。总之在这方面还有很多需要学习借鉴的地方。</p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>图片加载的主流类库有picasso, universal image loader, fresco, glide，volley等。下面首先对他们做一个简单的对比</p>
<h5 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h5><p>Picasso 是 square 出品的类库，它只缓存一个全尺寸的图片，默认为ARGB_8888格式，根据需求大小再压缩转换，因此它有着图片质量高的特点，加载速度一般。如果已经用了okhttp或者retrofit等square的库，再用picasso，picasso可以直接调用okhttp作为网络部分，体积很小。 优点：</p>
<ul>
<li>图片质量高</li>
<li>体积小</li>
<li>可以和square全家桶整合</li>
</ul>
<p>缺点：</p>
<ul>
<li>加载速度一般</li>
</ul>
<h5 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a>Fresco</h5><p>Fresco 是 facebook出品，Fresco 将图片放到一个特别的内存区域叫 Ashmem 区，就是属于 Native 堆，图片将不再占用 App 的内存，Java 层对此无能为力，这里是属于 C++ 的地盘，所以能大大的减少 OOM。所以此库很强大，还支持图像渐进式呈现，不过用起来也更复杂一些，包也比较大，大概3M，底层涉及到的 C++ 领域，想读源码也比较困难。 优点：</p>
<ul>
<li>支持图像渐进式呈现</li>
<li>有自己特别的内存区域来处理缓存，避免oom</li>
</ul>
<p>缺点：</p>
<ul>
<li>框架比较大，大概有3m，增加apk体积</li>
<li>不支持gif动态图</li>
<li>操作较为复杂，有一定学习成本</li>
</ul>
<h5 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h5><ul>
<li><em>Glide</em> 是 google员工出品，也是google推荐的图片加载库，它是完全基于 Picasso 的，沿袭了 Picasso 的简洁风格，但是在此做了大量优化与改进。Glide 默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，这个内存开销要小一半。 在磁盘缓存方面，Picasso 只会缓存原始尺寸的图片，而 Glide 缓存的是多种规格，也就意味着 Glide 会根据你 ImageView 的大小来缓存相应大小的图片尺寸。</li>
</ul>
<p>优点：</p>
<ul>
<li>加载速度快</li>
<li>支持gif动态图</li>
</ul>
<p>缺点：</p>
<ul>
<li>图片质量相对fresco低</li>
</ul>
<h5 id="UniversalImageLoader"><a href="#UniversalImageLoader" class="headerlink" title="UniversalImageLoader"></a>UniversalImageLoader</h5><p><em>Universal Image Loader</em>应该是图片加载方面最老牌也是最火的库了，项目从2011年一直维护到15年底，至今仍是github上star最多的库，无数的成熟项目采用了这个库来进行图片加载。 优点：</p>
<ul>
<li>成熟稳定</li>
<li>灵活高自定义</li>
</ul>
<p>缺点：</p>
<ul>
<li>开发者宣布于15年9月开始不再维护</li>
</ul>
<p>本项目由于笔者写项目时使用了一些以前项目用过的模块化代码，同时考虑到初期成熟稳定的需求，就暂时沿用了UniversalImageLoader库作为图片加载库。考虑到之后可能会替换图片库， 所以项目中采用的都是经过笔者二次封装的代码，这样之后如果需要修改图片加载库也相对容易。</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>目前主流的网络请求库有okhttp, retrofit, volley等。其中okhttp和retrofit都是square出品等，volley是google出品的。volley更适用于数据量小，通信频繁的情况，对于大数据量情况表现较差，而且现在google官方也认可了okhttp，并在android中使用，并且可以和square的各个库相配合，所以这儿选择了业界主流的okhttp作为主要网络请求框架。 因为项目api没有设计成resetful风格，所以在这儿没有使用retrofit。同时为了稳定快捷，直接使用了二次封装好的okhttputils，就没有用自己造的轮子了。</p>
<h3 id="网络解析"><a href="#网络解析" class="headerlink" title="网络解析"></a>网络解析</h3><h5 id="json解析"><a href="#json解析" class="headerlink" title="json解析"></a>json解析</h5><p>常用的有Gson，fastjson，这里因为数据定制性较强，而且api数量不太大，直接封装了一个具体的数据解析操作来手动解析了。</p>
<h5 id="html解析"><a href="#html解析" class="headerlink" title="html解析"></a>html解析</h5><p>常用的有HtmlParser，jsoup等，项目中很少用到且领域性强，所以写了一个项目针对性的强的手动解析类。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>常用的数据库框架有OrmLite, Sugar, GreenDAO, Realm等，考虑到该项目数据库内容较轻，该项目没有使用数据库框架，直接简单的将数据库对象和项目具体的一些操作封装为一个单例来使用。</p>
<h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h3><p>常用的事件总线库有Eventbus, otto等， 还有Rxjava（这儿应该是RxAndroid）其实也可以实现，这儿考虑到EventBus 3.0已经不再使用反射来实现，提高了速度，而Rxjava在该项目中由于没有使用retrofit，考虑再三还是没有在该项目中引入。所以综上这儿使用Eventbus作为事件总线库来传递消息。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>常用的依赖注入有ButterKnife，Dagger2等，这儿因为项目规模还不是特别大，而且是独立快速开发，就使用的更加轻便的Butterknife作为依赖注入工具。</p>
<h3 id="Log-框架"><a href="#Log-框架" class="headerlink" title="Log 框架"></a>Log 框架</h3><p>常用的log框架有Logger，Hugo，Timeber等，这儿考虑到项目等规模不是很大，就自己手写了一个带有log级别调控，以及出错位置显示，可以自动将tag换成出错的具体类名，从而可以不用写tag的基本log库，目前已经可以满足现有的log需求。</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>常用测试框架有Mockito，Robotium, Robolectric等，项目引入了Mockito作为基本的单元测试框架。</p>
<h3 id="内存检测"><a href="#内存检测" class="headerlink" title="内存检测"></a>内存检测</h3><p>项目使用了LeakCanary和Mat两个工具，结合Android stuido进行内存泄漏的检测，消除了部分内存泄漏隐患。</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>由于是商业项目，所以这里选用了免费私有库的Bitbucket结合Git作为版本控制工具。</p>
<h2 id="项目中遇到的技术难点"><a href="#项目中遇到的技术难点" class="headerlink" title="项目中遇到的技术难点"></a>项目中遇到的技术难点</h2><h3 id="复杂滑动冲突的解决方案"><a href="#复杂滑动冲突的解决方案" class="headerlink" title="复杂滑动冲突的解决方案"></a>复杂滑动冲突的解决方案</h3><h5 id="webview中banner与外部viewpager的滑动冲突的解决方案"><a href="#webview中banner与外部viewpager的滑动冲突的解决方案" class="headerlink" title="webview中banner与外部viewpager的滑动冲突的解决方案"></a><em>webview中banner与外部viewpager的滑动冲突的解决方案</em></h5><p>这个情况是这样的，webview的html中用js写了一个可以左右滑动的banner和多个可以左右滑动的scroll条，而整个webview又被嵌套在一个左右滑动viewpager里，因此这个viewpager就和webview中的内容产生了滑动冲突。 一开始想到的是对固定高度的banner进行特判的方法，但是马上想到还有多个scroll条需要滚动，而且对像素进行特判在丰富的android系统类型和手机型号上并不是一个好想法，所以就放弃了这个方案。 经过多方搜索，包括在stackoverflow上也没有找到一个好的解决方案。于是不得已就想到了利用js联合native方法来进行判断的方法。 具体就是通过javainterface写一个本地的js交互类，这个js交互类中写有控制这一时刻viewpager是否拦截aciton的方法，每当手触碰（ontouch)到相应被绑定了js的dom对象，就会触发这个方法。经过android端js注入测试成功后，再让html端将js代码写到网页中，即可成功部署。 这个方法的优点在于可以根据对象来判断是否触碰，不再需要关心具体的高度，ontouch的函数的反应很快，即使快速滑动也能准确的快速反应出来，而且适合于任何html对象。缺点在于，在重新显示网页时，js载入稍有延迟，在性能较低的手机上重新显示网页时，如果同时很快的进行滑动，可能会一下反应不过来从而拦截这次action失败，不过目前暂时也没有找到更好的方法解决这个问题，也希望大家能给出更好的方法。</p>
<h5 id="多层嵌套的纵向滑动冲突的解决方案"><a href="#多层嵌套的纵向滑动冲突的解决方案" class="headerlink" title="多层嵌套的纵向滑动冲突的解决方案"></a><em>多层嵌套的纵向滑动冲突的解决方案</em></h5><p>这个情况是有一个可以左右滑动的viewpager中有两个可以上下滑动并带有上拉刷新下拉加载功能的recyclerview，而在这个viewpager上方又有较为复杂的界面。现在需要在滑动时先将上方复杂界面滑动，当上方复杂界面滑动到看不见时，则开始滑动下方的recyclerview。 这个需求我首先理解的是一个可以上下滑动的外部的scrollview嵌套了一个可以上下滑动的recyclerview。由于recyclerview位于viewpager内部，所以不能直接将上方界面作为head放于头部。而且这里的recylerview也不能在viewpager中设置viewport = true来解决滑动冲突， 因为这样将丧失recylcerview复用的特性，因此必须要考虑一个内外滑动的问题。 对于这种嵌套，可以使用外部拦截或者内部拦截。因为外部的scrollview和内部的recyclerview相距层数很远，而且业务逻辑比较复杂，所以我先选取了外部拦截法进行实现。但是具体实现的时候，发现了几个问题。 一是对于上方的界面与recyclerview交界位置的确定比较繁杂，因为涉及到具体像素位置，调用了多个android系统库以及多个界面对象的测量函数才最终确定成功。 二是由于逻辑较为复杂，需要的接口太多，而且由于层级过深，每一个接口需要多次传递，较为繁杂。 三是由于下拉加载的存在，reclcerview应该是一个动态扩展的长度，所以对recyclerview的测量（measure）需要注意，以免出现recyclerview不能展开的情况。 四是一个未能解决的问题，而这个问题是android本身事件分发的机制引起的。首先放一张图来整体说明一下事件分发的过程，以便对后面的说明又一个清晰的理解，图来源于简书上<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">Kelin的博客</a> <img src="http://upload-images.jianshu.io/upload_images/966283-d01a5845f7426097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="android事件分发"> 如图可以看到整个分发过程呈现一个u型，从顶级activity分发到viewgroup再到view，然后再回到每一层的onTouchEvnet，而android的默认设计（return super.xxxx())就是走完这个u型的调用路线. 其中viewgroup和view都有的dispathTouchEvent方法，如果return true, 就表明消费掉了这个touch事件，事件停止传递，也没有人包括它自己再收到或者处理这个事件了。如果dispathTouchEvent事件return false，则直接往上一层viewgroup的onTouchEvent传递，即向父view回溯，不再向下分发。 这个函数的默认（super调用）形式，在viewgroup中是调用onIntercepteTouchEvent进行处理。而对于view，由于没有onInterceptTouchEvent这一拦截器，所以默认实现就是调用自己的onTouchEvnet处理，不需要拦截了。 而ViewGroup特有的onInterceptTouchEvent函数如果return true，就会直接交给自己的onTouchEvent处理，如果return false，就和默认的super实现一样，不拦截继续向下分发，进入子view的dispachEvent。 至于viewgroup和view都有的onTouchEvent,则是return true就直接消费掉，不再传递也不再处理。如过return false，则和默认实现一样，也和dispathEvnet的fasle一样，直接回溯到父view的onTouchEvent进行处理。 以上是对于action down的事件分发，而对于后续的action move 和up，则是如果你最终在某一个view的onTouchEvent处消费了action down，那么action move和up在从上到下分发时，只传到这个控件的onTouchEvent为止，不再继续分发。 现在再来说一下这个具体的问题。首先重现一个这个情况，就是当我点下上方的界面时，会触发一个aciton down事件，这时候上方的scrollview（被重写过onInterceptTouchEvent函数）会返回false（为了之后的拦截，不需要拦截down事件，因为如果拦截了down事件那么之后的所有事件都将直接分发给该scrollview的onTouchEvent事件，而不经过onInterceptTouchEvent函数和子view了，那样就无法根据业务逻辑处理move事件的分发了），这时down事件会继续分发到下方的子view，由于下方的recyclerview并没有位于这个位置，所以没有人消费这个事件，最后这个事件将一直逐层向上传，直到scrollview的onTouchEvent将其消费掉。之后接着的move事件，符合scrollview拦截的要求，scrollview将拦截这个事件，即onInterceptTouchEvent返回true，调用scrollview的onTouchEvent将move事件进行消费。到目前为止还很正常。 但是当继续快速滑动时，很快屏幕顶部和recyclerview顶部已经对齐，而手指还没有到屏幕顶部，这时就会发现不能滑动了，因为recycelerview没有获得action down事件，所以后续的事件也无法获得，因此一次完整的滑动事件（一个action down加一连串的action move）无法实现先滑动外部scrollview，再滑动内部recyclerview。这样每次从页面顶部滑动就就会这样在这儿卡一下，等再一次用手从recyclerview开始滑动时才会继续滑动，不能流畅的一体滑动，也可以理解为需要第一步把头部收起，第二步才可以滑动，虽然还能够接受，但是对体验还是有一定影响。 既然这种方案有这么多瑕疵，那么不如换一个方案吧。不久在design library中我就发现了一个完美的解决方案，那就是CoordinatorLayout加AppBarLayout的实现方法。 这个方法不仅完美实现了一次滑动可以滑动头部以及recyclerview，而且还十分简洁。主要就是在xml中引入CoordinatorLayout作为最高层布局，然后将viewpager上方复杂的界面全部放在一个LinearLayout中，再将这个LinearLayout放在AppBarLayout中，这个AppBarLayout就放在最高层的CoordinatorLayout中，然后再将viewpager也放在CoordinatorLayout中，并在viewpaer中加上一句 <code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior</code> 即可。于是就这样将这个纵向的滑动冲突以官方的形式解决了。</p>
<h3 id="首页预加载"><a href="#首页预加载" class="headerlink" title="首页预加载"></a>首页预加载</h3><p>这个具体的情形是在开发后期，测试觉得每次启动后需要等待首页中的webview的网页加载的时间，想避免这个不好的体验，于是提出了一个出现首页网页就已经加载好的需求。 由于这个时候首页和启动页都已经有了很复杂的逻辑，于是笔者在这里用了一个比较trick的方法，就是将启动页和首页合为一个大activity，其xml的最顶层布局改写为一个FrameLayout，在其中加上app启动页的图片盖在首页的所有界面之上。然后先进行启动页的逻辑，在启动页完成好必要的业务和相应的检查初始化后，利用启动页展示广告的2到3秒，提前加载首页中各个fragment，当首页中最先出现在眼前的那个webview中的网页load finish时，就发送一个回调消息给启动页逻辑，将盖在首页界面上的图片remove掉，则实现了这一需求。 主要是要注意启动页最大显示时间，和最短显示时间，以及有无网络连接，等等情况对启动逻辑的影响，也因为较为复杂的逻辑使得这个activty更为复杂。如果时间充裕可以考虑解耦性更好的方法。</p>
<h3 id="html5与native的通信方案"><a href="#html5与native的通信方案" class="headerlink" title="html5与native的通信方案"></a>html5与native的通信方案</h3><ul>
<li><em>html与native间的通信协议</em></li>
</ul>
<p>这里主要是点击html中的地址，或者加载其中的地址，将根据提前和html端协商好的协议在本地进行重定向，并通过地址中的参数获取相应的信息。比如 <code>review://app.com/?itemid=1000060</code> 则表示打开对id为1000060的商品的native评论页面。这样就可以简单的实现html与native页面的控制。 这儿有一点就是要注意，重加载函数shouldOverrideUrl()的调用时机问题。shouldOverrideUrl只有在你点击网页中的超链接时才会调用，也就是说如果你用一个webview直接载入url，这个函数是不会被调用的，所以不能仅仅依靠这个函数来实现协议封装。我的处理方式是在webview加载url之前，先调用处理函数对封装的url进行处理，再传入webview, 这样就可以应对任意形式的url传递方法了。</p>
<ul>
<li><em>js注入以及js interface的处理</em></li>
</ul>
<p>对于较为复杂的html行为，则可以通过定义@JavascriptInterface的方式，定义js交互函数，进行处理。还可以通过web.load(“javascript”+”function xxxxxx xxxx”)的方法进行js注入来快速调试和验证。</p>
<h3 id="可以左右滑动自动获取项目长度的顶部tabIndicator"><a href="#可以左右滑动自动获取项目长度的顶部tabIndicator" class="headerlink" title="可以左右滑动自动获取项目长度的顶部tabIndicator"></a>可以左右滑动自动获取项目长度的顶部tabIndicator</h3><p>这个主要是ui的需求，要求tab的下划线和文字宽度一样，而且宽度随之动态变化，而且加上颜色改变等一系列自定义的需求，发现网上没有能完全满足的开源库，于是就自己模仿HorizontalScrollView，结合view的measure和animation实现了一个，也算又造了一回轮子吧。</p>
<h3 id="webview和本地的cookie同步"><a href="#webview和本地的cookie同步" class="headerlink" title="webview和本地的cookie同步"></a>webview和本地的cookie同步</h3><p>项目中通过api获得的cookie需要同步到webview，以免需要反复登陆。这个最后采用了android自带的CookieManager来进行，原生的兼容性更好。而通过api获得Cookie的管理和持久化，则通过自己封装的一个类来实现的。</p>
<h3 id="喜欢按钮的实现"><a href="#喜欢按钮的实现" class="headerlink" title="喜欢按钮的实现"></a>喜欢按钮的实现</h3><p>这个是指app各个地方的小红心按钮，这个主要是实现比较繁杂，点击任意一个喜欢按钮，首先需要发送请求并等待相应回调，回调成后，除了改变自己颜色，还将会更新“热门页面”三个排行的相应显示，以及“主题”页面的相应显示，还将在“我”页面的收藏中增删条目，这里是用了handler传递和观察者模式实现的，但觉得还是有很多可以优化的地方。</p>
<h3 id="特定页面的启动方式"><a href="#特定页面的启动方式" class="headerlink" title="特定页面的启动方式"></a>特定页面的启动方式</h3><p>android中有四种启动方式，分别是standard, singleTop, singleTask, singleInstance.而如何选用这些启动方式也很重要。 比如app的主页，就应该采用SingleTask的启动模式，这样不管当前回退栈的栈顶在哪儿，只要一句 <code>startActivity(intent);</code>就可以直接回到之前的主页，不会出现多个主页的情况。</p>
<h2 id="项目中可复用的经验"><a href="#项目中可复用的经验" class="headerlink" title="项目中可复用的经验"></a>项目中可复用的经验</h2><h3 id="第三方sdk原生接入"><a href="#第三方sdk原生接入" class="headerlink" title="第三方sdk原生接入"></a>第三方sdk原生接入</h3><h5 id="原生三方登陆实现"><a href="#原生三方登陆实现" class="headerlink" title="原生三方登陆实现"></a><em>原生三方登陆实现</em></h5><p>项目中使用了微博，微信，以及qq的sdk来实现三方登陆，出于定制性的考虑没有使用友盟和shareSDK。</p>
<h5 id="原生三方分享实现"><a href="#原生三方分享实现" class="headerlink" title="原生三方分享实现"></a><em>原生三方分享实现</em></h5><p>项目中的分享也是直接使用的三方sdk的原生方式实现，并将分享的模块进行了一定的封装，以便从内容中获取的分享标题，图片等内容可以方便的分发给任意一个选择的社交平台。但是还未加入统计等功能，如果有这方面的需求还需要继续研究一下。</p>
<h2 id="项目中的典型bug解决"><a href="#项目中的典型bug解决" class="headerlink" title="项目中的典型bug解决"></a>项目中的典型bug解决</h2><h3 id="Toast被部分安全软件或系统禁用的处理"><a href="#Toast被部分安全软件或系统禁用的处理" class="headerlink" title="Toast被部分安全软件或系统禁用的处理"></a>Toast被部分安全软件或系统禁用的处理</h3><p>由于各种禁止通知的安全软件的存在，以及有的定制系统中不显示通知的默认设定，所以在部分手机上系统自带的toast无法显示出来，对app的使用造成了困扰，于是笔者使用AlertDialog，并结合android系统中的toast资源，模仿写出了一套完全自定义的仿原生toast，从而绕开了通知的限制。 之后发现在有的手机的有的系统，比如小米最新的系统中，默认禁止了alertdialog的显示，所以之后又在封装的Toast单例的帮助类中加了一些对机型和系统的特判，来达到兼容的目的。</p>
<h3 id="部分机型系统上拍照或者从相册获取图片失败"><a href="#部分机型系统上拍照或者从相册获取图片失败" class="headerlink" title="部分机型系统上拍照或者从相册获取图片失败"></a>部分机型系统上拍照或者从相册获取图片失败</h3><p>这个也是一个android上很麻烦的问题，本来已经根据系统api等级作了判断，来调取不同的获取方式，但是在部分机型的系统（国产机丰富的定制系统真的让人头疼）上仍然失效，最后无奈使用了github上的一个兼容性很好的开源库TakePhoto暂时解决了这个问题。</p>
<h3 id="部分机型系统上popupWindow失效"><a href="#部分机型系统上popupWindow失效" class="headerlink" title="部分机型系统上popupWindow失效"></a>部分机型系统上popupWindow失效</h3><p>在部分机型系统上不能正常调用系统原生自带的popupWindow，使用开源库替换也不行，最后自己实现了一个。怀疑是系统通知权限之类的问题。</p>
<h2 id="项目使用的开源库"><a href="#项目使用的开源库" class="headerlink" title="项目使用的开源库"></a>项目使用的开源库</h2><p>come.pkmmte.view:circularimageview 圆形头像 com.squareup.okhttp3:okhttp 网络通信 com.nostra13.universalimageloader:universal-image-loader 图片加载 com.zhy:okhttputils 网络封装 com.bigkoo:pickerview 满足ui设计的生日选取ui库 org.greenrobot:eventbus 事件总线 in.srain.cube:ultra-ptr 下拉刷新框架 com.github.hotchemi:permissionsdispatcher 权限管理 com.jakewharton:butterknife 依赖注入 com.jph.takephoto:takephoto_library 照片获取 cundong/HeaderAndFooterRecyclerView recylerview扩展</p>
<h2 id="需要进一步探讨的地方"><a href="#需要进一步探讨的地方" class="headerlink" title="需要进一步探讨的地方"></a>需要进一步探讨的地方</h2><h3 id="app启动逻辑的改进"><a href="#app启动逻辑的改进" class="headerlink" title="app启动逻辑的改进"></a>app启动逻辑的改进</h3><p>由于启动时首先需要快速显示启动页，然后在显示中需要进行一系列判定，包括</p>
<ul>
<li>是否第一次打开app</li>
<li>是否有网络连接</li>
<li>是否获取了相应权限（针对android M动态获取权限的特性）</li>
<li>是否已经完成必要的信息填写</li>
<li>是否在线获取到数据库的各个表的资源</li>
<li>是否需要在线更新数据库</li>
<li>是否已经在线更新完商品类目</li>
<li>是否已经在线更新下载完类目图（为了尽量加快之后访问类目页的速度）</li>
<li>用户是否已经登陆过而且尚未注销</li>
<li>是否已经预加载完成首页</li>
<li>是否已经显示启动页达到最短显示时间</li>
<li>是否已经超过最长显示时间</li>
</ul>
<p>以及在主页和启动页合并后，还需要考虑</p>
<ul>
<li>当前页是主页还是启动页</li>
<li>当前页后退时应该直接finish所有activity还是回到某一个页面</li>
<li>当前页被销毁后应该如何恢复</li>
</ul>
<p>可以看到需要考虑的问题很多，因此很容易写出混乱的代码。这里暂时是利用模块化的函数设计，尽量提高代码复用来避免混乱的逻辑的，如果要重构可以考虑引入一些解耦度更高的设计模式来实现，具体的重构方式还需要进一步思考。</p>
<h3 id="消息传递的改进"><a href="#消息传递的改进" class="headerlink" title="消息传递的改进"></a>消息传递的改进</h3><p>项目中需要消息传递的地方比较多，而该项目的消息传递主要使用了EventBus和Handler。Handler是系统原生自带的，使用还是比较方便，但是传输实体等需要序列化传输等数据时略显麻烦。EventBus虽然可以比较方便的传递消息和实体，但是如果在项目中过多使用的话，很容易引起程序消息传递的时序和目标混乱，不利于review和测试。而且EventBus每一组Observer和其观察的subject之间都需要一个Event类，很容易在项目中引入过多的Event类，影响项目等管理。这一点的改进还需要进一步思考，感觉从程序的架构和设计模式入手会有一些办法。</p>
<h2 id="收获与展望"><a href="#收获与展望" class="headerlink" title="收获与展望"></a>收获与展望</h2><p>总的来说，这次项目也是对自己的一个很好的锻炼，对Android各个方面的知识都有了进一步的提高。具体体现在：</p>
<ul>
<li>学习研究了android系统的优秀源码，包括activity生命周期中各部分的源码探究，IPC机制的源码学习，以及反复研读了view的事件分发体系以及view的测量绘制相关的一些列源码。通过这些阅读和学习，对android系统以及很多设计模式都有了更深的理解。</li>
<li>对各个主流开源库更加熟悉和了解，并自己根据业务需要修改了一些开源库，将其用在了项目当中，也提交了一些关于bug的issue，作者也回应并更改，也算对开源社区做了一点微小的贡献。</li>
<li>自己累积了更多更成熟的app设计方法，封装了更多的工具库，以后再开发类似的产品将会更快更成熟。</li>
</ul>
<p>而之后一段时间应该暂时不会写完整的android项目了，在技术方面主要还是多刷一下算法题，练习一下基础，语言上应该就继续深入学习java，有机会也练习一下Scala和Js，一步一步向全栈之路进发。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写下这篇项目总结时，因为时间匆促，可能有不少遗漏或者疏忽，在开发过程中的思想，也可能有很多错误，如果您有什么批评和意见，都欢迎和我联系，谢谢！我的邮箱<a href="mailto:fan12356789@gmail.com" target="_blank" rel="noopener">fan12356789@gmail.com</a>.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2017/03/28/xcodebuild-error-scheme-xxx-is-not-currently-configured-for-the-clean-action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/28/xcodebuild-error-scheme-xxx-is-not-currently-configured-for-the-clean-action/" itemprop="url">xcodebuild: error: Scheme XXX is not currently configured for the clean action</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T20:51:17+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ios/" itemprop="url" rel="index">
                    <span itemprop="name">ios</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ios/经验杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">经验杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>if you face that problem in Carthage upgrade opreation , just delete the checkout that Carthage has download, the n re-run `carthage update` and everything will be fine now.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/11/09/the-experiment-of-adroid-getparent-in-fragments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/09/the-experiment-of-adroid-getparent-in-fragments/" itemprop="url">Android getParent() 在嵌套fragment中的实验</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-09T22:16:44+08:00">
                2016-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用requestDisallowInterceptTouchEvent()方法时，常会用到getParent()方法，那么就有一个问题，在复杂的fragment嵌套的时候，getparent的效果是怎样的呢。 源码里面是这么给的</p>
<pre><code>/\*\*
 \* Gets the parent of this view. Note that the parent is a
 \* ViewParent and not necessarily a View.
 \*
 \* @return Parent of this view.
 */
public final ViewParent getParent() {
    return mParent;
}
</code></pre><p>好像也不是很清楚，再去看api文档，也只说了一句getParent() Gets the parent of this view. 既然这样，那就做一个简单的实验吧。 这儿有一个比较复杂的嵌套例子，首先是一个main activity，layout如下</p>
<linearlayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout\_width="match\_parent" android:id="@+id/container" android:background="@color/white" android:layout\_height="match\_parent"><br><br>    <framelayout android:id="@+id/main_fl" android:layout\_width="match\_parent" android:layout_height="0dp" android:layout_weight="1"><br>        <fragment android:id="@+id/fragment" android:name=".MainFragment" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br>    </fragment></framelayout><br></linearlayout>

<p>其中的Mainfragment的layout如下</p>
<relativelayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br>    <viewpager android:id="@+id/viewpager" android:layout\_below="@id/horizontal\_bar" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br></viewpager></relativelayout>

<p>viewpager中装载的fragment的layout如下</p>
<linearlayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br><webview android:id="@+id/webview" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br></webview></linearlayout>

<p>现在，我们在这个被装载在viewpager中的frament中插入以下代码</p>
<p>  Clog.d(“parent tree “ + webView + webView.getParent() + “ “<br>                            + webView.getParent().getParent() + “ “+ webView.getParent().getParent().getParent() + “ “ +<br>                            webView.getParent().getParent().getParent().getParent());</p>
<p>查看其parent，可以整理结果可以看到依次为</p>
<p>android.webkit.WebView<br>android.widget.LinearLayout<br>android.support.v4.view.ViewPager<br>android.widget.RelativeLayout<br>android.widget.FrameLayout</p>
<p>所以我们得出结论，parent与fragment本身无关，不管是动态还是静态的fragment标签都不算是parent，在考虑parent的时候，只需要忽略掉framgent的存在，按照获取时整个屏幕真实的嵌套关系考虑即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/08/08/android-bug-fix-exprience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/android-bug-fix-exprience/" itemprop="url">Android bug fix笔记（未完待续...）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-08T21:36:17+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Careless篇</strong> 1.当你把RelativeLayout改成LinearLayout时，永远不要忘记加上orientation ! 2.如果你往代码里直接加入了一些测试语句，比如删除某一个数据库，一定要记得加上log.e(“database has deleted!”)来提醒自己！不然以后测试时可能会忘记</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/the-longest-common-subsequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/the-longest-common-subsequence/" itemprop="url">最长公共子序列(LCS)</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T18:37:24+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先说子序列的定义，在一个序列中删去若干元素后得到的序列即为其子序列。 最长公共子序列问题的描述：给定两个序列X = {x1, x2, …, xm}, Y = {y1, y2, …, yn}, 求X和Y的最长公共子序列。 下面举个例子说明一下，X = {A,B,C,B,D,A,B},Y = {B,D,C,A,B,A}，那么他们的最长公共子序列为{B,C,B,A}. 最长公共子序列具有最优子结构的性质。设序列X和Y的最长公共子序列为Z={z1,z2,…,zk} ，则有 (1)若[latex]x_m=y_n，则z_k=x_m=y_n[/latex]，且[latex]Z_{k-1}[/latex]是[latex]X_{m-1}和Y_{n-1}[/latex]的最长公共子序列。 (2)若[latex]x_m≠y_n且z_k≠x_m[/latex]，则[latex]Z[/latex]是[latex]X_{m-1}[/latex]和[latex]Y[/latex]的最长公共子序列。 同理既然 (3)若[latex]x_m≠y_n且zk≠yn[/latex]，则[latex]Z[/latex]是[latex]X[/latex]和[latex]Y_{n-1}[/latex]的最长公共子序列。 对于(1),因为既然是最长公共子序列，若[latex]z_k不取x_m[/latex],那就不是最长了，形成矛盾。而当X,Y均去掉这个相等的元素后，明显[latex]Z_{k-1}[/latex]，即去掉该元素的Z，为剩下的X,Y的LCS. 对于(2)，既然[latex]z_k≠x_m[/latex]，那么X去掉[latex]x_m[/latex]也不会影响LCS.对于(3)同理。 这三条合起来，说明了两个序列的LCS包含了这个两个序列前缀的LCS，即LCS问题有最优子结构。具体在这里就是Z里一定包含有X,Y前缀的LCS。(若X为{A,B,C},X的所有前缀为{A},{A,B},{A,B,C}) 因为已经知道其最优子结构的特点，定义c[i][j]为[latex]X_i, Y_j[/latex]的LCS的长度，我们可以设计以下递归关系来求解 $$ c[i][j]=\left\{ \begin{array}{lcl} 0 &amp; &amp; {i = 0, j = 0}\\ c[i-1][j-1]+1 &amp; &amp; {i,j &gt; 0; x_i = x_j}\\ max(c[i][j-1], c[i-1][j]) &amp; &amp; {i,j &gt; 0; x_i \not= x_j} \end{array} \right. $$ 当i = 0, j = 0 时，X,Y为空串，LCS长度为0；当[latex]x_i = x_j[/latex]时，由上述的性质(1)可得当前LCS为[latex]X_{m-1}[/latex]和[latex]Y_{n-1}[/latex]的LCS末尾添上一个x_m；当[latex]x_i \not= x_j[/latex]时，说明当前x和y不等，那么LCS一定和[latex]X_{m-1}，Y[/latex]所得到的LCS或者和[latex]Y_{n-1}，X[/latex]所得到的LCS相等。可以结合下面这张图来理解 <img src="http://fanyijie.net/wp-content/uploads/2016/06/lcs-300x283.png" alt="lcs"> 因为每进行一次递归都有i-1或j-1，所以算法复杂度为O(m + n).</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/knapsack-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/knapsack-problem/" itemprop="url">背包问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T15:56:49+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背包问题是在1978年由Merkel和Hellman提出的经典问题。它属于NP完全问题，在规模较小的时候可以用动态规划进行求解。 在说经典的背包问题前，我们先看一个简化的小数背包问题。已知一个容量大小为M重量的背包和n种物品，物品i的重量为[latex]w_i[/latex],假定物品i的一部分[latex]x_i[/latex]放入背包会得到[latex]v_i<em>x_i[/latex]这么大的收益，这里，[latex]0 &lt;= x_i &lt;= 1, v_i &gt; 0[/latex]。采用怎样的装包方法才会使装入背包的物品总效益最大？ 这里由于物品是可分的，所以我们直接贪心就可以求解。求出[latex]v_i/w_i[/latex]的值，然后优先放[latex]v_i/w_i[/latex]大的就行了。 现在加一个限制，如果物品不可分我们又应该采取怎样的策略呢？具体一点说，我们现在考虑这样的情况：对物品i只有两个选择，装入背包或者不装入背包，不能将i装入多次，也不能只装部分。这就是我们现在要说的0-1背包问题。 0-1背包问题是一个特殊的整数规划，用反证容易得到其最优子结构的特性。我们定义m(i, j)为背包容量为j, 前i件物品可选的最优值，则可得其转移方程为 $$ m(i, j)=\left\{ \begin{array}{lcl} max(m(i-1, j), m(i-1, j-w_i)+v_i) &amp; &amp; {j \ge w_i}\\ m(i-1, j) &amp; &amp; {0 \leq j \leq w_i} \end{array} \right. $$ 因为对于每一个物品i，若当前背包容量大于[latex]w_i[/latex]，那么就有两种选择：装入或者不装入，装入时即为[latex]m(i-1, j-w_i)+v_i)[/latex]，可选物品减少，背包容量也减少，背包价值增加；不装入时即为[latex]m(i-1, j)[/latex]，可选物品同样减少，由于未选所以背包价值不变，容量不变。我们取这两种选择中的最大值，即可保证该选择是当前最优的。若背包容量小于[latex]w_i[/latex]，那么就只能不选i物品了，和没选该物品的情况是一样的。只要我们保证每一次选择是当前最优的，根据最优子结构的性质，最后的最终结果m[n][c]即为问题最优解。 根据m(i, j)定义可知边界值如下 $$ m(1, j) = \left\{\begin{array} vv_1 &amp; &amp; {j \ge w_1}\\ 0 &amp; &amp; {0 \le j &lt; w_1} \end{array} \right. $$ 根据转移方程，我们可以看出算法的时间复杂度[latex] T(n) = O(n\</em>c)[/latex],空间复杂度为同样为[latex]T(n) = O(n*c)[/latex].但是如果仔细观察递归表的话，可以发现这个算法在空间上还可以进行优化。可以巧妙的利用循环的顺序，使得第i次循环结束后的m(j)就就是之前的m(i, j)，这样最后只要输出m[c]就可以了，将空间复杂度优化到了[latex] O(C)[/latex]. 则此时的转移方程为 $$ m(j) =\left\{ \begin{array}{lcl} max(m(j), m((j - w_i) + v_i) &amp; &amp; {j \ge w_i}\\ m(j) &amp; &amp; {0 \leq j \leq w_i} \end{array} \right. $$ 注意此时的循环应该是外循环i从1到n，然后内循环j从c到wi逆序遍历。 未完待续</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/matrix-chain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/matrix-chain/" itemprop="url">矩阵连乘</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T14:16:21+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>矩阵连乘是一个经典的动态规划问题。例如给定三个矩阵{A1,A2,A3},以及这三个矩阵的维数{10，100，5，50}，表示A1矩阵为10*100，A2为100*5，A3为5*50，那么他们相乘有两种方式，一种是((A1*A2)*A3),由矩阵乘法的标准算法，可知这样共需10*100*5 + 10*5*50 = 7500次数乘.另一种是(A1*(A2*A3)),需10*5*50 + 10*100*50 = 75000次数乘。所以加括号的方法对于计算量的影响是很大的。 现在我们的问题就是，对于一个给定合法连乘积A1*A2<em>…\</em>An，怎么求出其计算量最小的乘法次序。 为方便起见，我们记Ai*…*Aj为A[i, j], 记第i个矩阵的维数为Pi-1*Pi。首先观察到, 如果整个A[1，n]的计算次序最优，那么A[1, k]和A[k+1, n]的计算次序也是最优的。对这点可以反证，如果有比现在的A[1, k]更优的次序，则用该次序替换现在的次序，得到的新的A[1, n]也将更优，所以推出矛盾。这证明了该问题是满足最优子结构的。 下面我们再观察其是否具有重叠子问题的特性。定义m[i, j]为计算A[i, j]所需要的最小计算量，则原问题最优解为m[1, n]，根据矩阵连乘的特性，容易写出转移方程为 [latex]M[i][j] = min( m[i][k] + m[k+1][j] + P_{i-1} <em> P_k</em>P_j )[/latex] 其中i&lt;=k&lt;j, 且边界为i = j时m[i][j] = 0(此时为单个矩阵，计算量为0)。如果我们直接按照这个式子自顶向下，也就是从m[1][n]向下递归，那么明显将有大量的重复计算，因为不同的子问题个数最多为[latex]C^2_n + n = \theta(n^2)[/latex]个，而递归时计算是指数增长的。如果画出递归关系图，你可以更清晰的发现这种重叠子问题的特性。 于是我们可以发现，动态规划最基本的两个要素——最优子结构，重叠子问题，矩阵连乘都满足了，下面我们就用动态规划来解决这个问题吧。这里增加一个S数组作为最优解的记录。首先给自底向上的动规代码如下</p>
<p>#include<cstdio><br>using namespace std;<br>const int N = 10;<br>int p[7] = {30, 35, 15, 5, 10, 20, 25};<br>int m[N][N];<br>int s[N][N];<br>void MatrixChain(int n) {<br>    for(int i = 1; i &lt;= n; i++) {//边界初始化<br>        m[i][i] = 0;<br>    }<br>    for(int r = 2; r &lt;= n; r++) {//r代表当前矩阵连乘序列的长度<br>        for(int i = 1; i &lt;= n - r + 1; i++) { //i代表矩阵连乘序列的起始位置<br>            int j = i + r - 1; //j代表矩阵连乘序列的最终位置<br>            m[i][j] = m[i+1][j] + p[i-1] <em> p[i] </em> p[j]; //m[i][i] = 0 所以可以省略<br>            s[i][j] = i;<br>            for(int k = i + 1; k &lt; j; k++) {<br>                int t = m[i][k] + m[k+1][j] + p[i-1] <em> p[k] </em> p[j];//转移方程<br>                if(t &lt; m[i][j]) {<br>                    m[i][j] = t;<br>                    s[i][j] = k;//记录括号位置<br>                }<br>            }<br>        }<br>    }<br>}<br>void Traceback(int i,int j) {<br>    if(i == j) return;<br>    Traceback(i, s[i][j]);//递归打印k和k左边的<br>    Traceback(s[i][j] + 1, j);//递归打印k右边的<br>    printf(“Mutiply A%d,%d and A%d,%d\n”, i, s[i][j], s[i][j]+1, j);<br>}<br>int main(){<br>    MatrixChain(6);<br>    for(int i = 1; i &lt; 7; i++){<br>        for(int j = 1; j &lt; 7; j++){<br>            if( i &gt; j){<br>                printf(“    “);<br>            }<br>            else<br>            printf(“%-8d”, m[i][j]);<br>        }<br>        printf(“\n”);<br>    }<br>    printf(“%d\n”, m[1][6]);<br>    Traceback(1, 6);<br>}</cstdio></p>
<p>运行结果如下</p>
<p>0       15750   7875    9375    11875   15125<br>        0       2625    4375    7125    10500<br>                0       750     2500    5375<br>                        0       1000    3500<br>                                0       5000<br>                                        0<br>15125<br>Mutiply A2,2 and A3,3<br>Mutiply A1,1 and A2,3<br>Mutiply A4,4 and A5,5<br>Mutiply A4,5 and A6,6<br>Mutiply A1,3 and A4,6</p>
<p>可以看到右上角就是我们的答案，对角线的0就是我们的初始边界，然后以此为基础，每次沿主对角线向右下方向进行计算，由于每次计算都只需要用到该位置左边和下边的m[i][j]，而按照我们循环的方向，这些值都已经计算过了，所以直接使用这些值就可以了。这就是自底向上的循环递归。 此外还可以使用备忘录方法进行递归，也就是所说的记忆式搜索，每次将计算过的m储存起来，还是像最开始所说的那样自顶向下进行递归，但是如果遇到该m已经计算过，那么就把它直接返回而不进行重复计算。代码如下</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring><br>using namespace std;<br>const int N = 10;<br>int p[7] = {30, 35, 15, 5, 10, 20, 25};<br>int m[N][N];<br>int s[N][N];<br>int lookupChain(int i, int j){<br>    if(m[i][j] &gt; 0) {//如果已经计算过(!0)则直接返回该值<br>        return m[i][j];<br>    }<br>    if(i == j){//注意递归边界<br>        return 0;<br>    }<br>    int u = lookupChain(i, i) + lookupChain(i+1, j) + p[i-1]*p[i]*p[j];//状态转移方程，递归调用<br>    s[i][j] = i;<br>    for(int k = i + 1; k &lt; j; k++){<br>        int t = lookupChain(i, k) + lookupChain(k+1, j) + p[i-1]*p[k]*p[j];//状态转移方程，递归调用<br>        if(t &lt; u) {<br>            u = t;<br>            s[i][j] = k;<br>        }<br>    }<br>    m[i][j] = u;<br>    return u;<br>}<br>int MemorizedMatrixChain(int n) {<br>    memset(m, 0, sizeof(m)); //如果以后要重复调用，则需要初始化<br>    return lookupChain(1, n);<br>}<br>void Traceback(int i,int j) {<br>    if(i == j) return;<br>    Traceback(i, s[i][j]);<br>    Traceback(s[i][j] + 1, j);<br>    printf(“Mutiply A%d,%d and A%d,%d\n”, i, s[i][j], s[i][j]+1, j);<br>}<br>int main(){<br>    MemorizedMatrixChain(6);<br>    for(int i = 1; i &lt; 7; i++){<br>        for(int j = 1; j &lt; 7; j++){<br>            if( i &gt; j){<br>                printf(“    “);<br>            }<br>            else<br>            printf(“%-8d”, m[i][j]);<br>        }<br>        printf(“\n”);<br>    }<br>    printf(“%d\n”, m[1][6]);<br>    Traceback(1, 6);<br>}</cstring></p>
<p>备忘录算法与自底而上的循环算法一样，都是[latex]O(N^3)[/latex]的，其区别在于如果子问题空间中的部分子问题可以不用求解时，用备忘录方法比较好，因为该方法只求解那些确实需要求解的子问题。而对于每个子问题都至少要求解一次时，自底而上的动规因为只需要循环即可实现，应该会更好一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Fan Yijie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fan31415" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fanyije@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fan Yijie</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
