<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo-32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo-16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.ong?v=5.1.4" color="#222">





  <meta name="keywords" content="fanyijie, technology" />










<meta property="og:type" content="website">
<meta property="og:title" content="Fan&#39;s Home">
<meta property="og:url" content="https://fanyijie.net/page/3/index.html">
<meta property="og:site_name" content="Fan&#39;s Home">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fan&#39;s Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanyijie.net/page/3/"/>





  <title>Fan's Home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fan's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2017/03/28/xcodebuild-error-scheme-xxx-is-not-currently-configured-for-the-clean-action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/28/xcodebuild-error-scheme-xxx-is-not-currently-configured-for-the-clean-action/" itemprop="url">xcodebuild: error: Scheme XXX is not currently configured for the clean action</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T20:51:17+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ios/" itemprop="url" rel="index">
                    <span itemprop="name">ios</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ios/经验杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">经验杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>if you face that problem in Carthage upgrade opreation , just delete the checkout that Carthage has download, the n re-run `carthage update` and everything will be fine now.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/11/09/the-experiment-of-adroid-getparent-in-fragments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/09/the-experiment-of-adroid-getparent-in-fragments/" itemprop="url">Android getParent() 在嵌套fragment中的实验</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-09T22:16:44+08:00">
                2016-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用requestDisallowInterceptTouchEvent()方法时，常会用到getParent()方法，那么就有一个问题，在复杂的fragment嵌套的时候，getparent的效果是怎样的呢。 源码里面是这么给的</p>
<pre><code>/\*\*
 \* Gets the parent of this view. Note that the parent is a
 \* ViewParent and not necessarily a View.
 \*
 \* @return Parent of this view.
 */
public final ViewParent getParent() {
    return mParent;
}
</code></pre><p>好像也不是很清楚，再去看api文档，也只说了一句getParent() Gets the parent of this view. 既然这样，那就做一个简单的实验吧。 这儿有一个比较复杂的嵌套例子，首先是一个main activity，layout如下</p>
<linearlayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout\_width="match\_parent" android:id="@+id/container" android:background="@color/white" android:layout\_height="match\_parent"><br><br>    <framelayout android:id="@+id/main_fl" android:layout\_width="match\_parent" android:layout_height="0dp" android:layout_weight="1"><br>        <fragment android:id="@+id/fragment" android:name=".MainFragment" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br>    </fragment></framelayout><br></linearlayout>

<p>其中的Mainfragment的layout如下</p>
<relativelayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br>    <viewpager android:id="@+id/viewpager" android:layout\_below="@id/horizontal\_bar" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br></viewpager></relativelayout>

<p>viewpager中装载的fragment的layout如下</p>
<linearlayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br><webview android:id="@+id/webview" android:layout\_width="match\_parent" android:layout\_height="match\_parent"><br></webview></linearlayout>

<p>现在，我们在这个被装载在viewpager中的frament中插入以下代码</p>
<p>  Clog.d(“parent tree “ + webView + webView.getParent() + “ “<br>                            + webView.getParent().getParent() + “ “+ webView.getParent().getParent().getParent() + “ “ +<br>                            webView.getParent().getParent().getParent().getParent());</p>
<p>查看其parent，可以整理结果可以看到依次为</p>
<p>android.webkit.WebView<br>android.widget.LinearLayout<br>android.support.v4.view.ViewPager<br>android.widget.RelativeLayout<br>android.widget.FrameLayout</p>
<p>所以我们得出结论，parent与fragment本身无关，不管是动态还是静态的fragment标签都不算是parent，在考虑parent的时候，只需要忽略掉framgent的存在，按照获取时整个屏幕真实的嵌套关系考虑即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/08/08/android-bug-fix-exprience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/android-bug-fix-exprience/" itemprop="url">Android bug fix笔记（未完待续...）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-08T21:36:17+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Careless篇</strong> 1.当你把RelativeLayout改成LinearLayout时，永远不要忘记加上orientation ! 2.如果你往代码里直接加入了一些测试语句，比如删除某一个数据库，一定要记得加上log.e(“database has deleted!”)来提醒自己！不然以后测试时可能会忘记</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/the-longest-common-subsequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/the-longest-common-subsequence/" itemprop="url">最长公共子序列(LCS)</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T18:37:24+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先说子序列的定义，在一个序列中删去若干元素后得到的序列即为其子序列。 最长公共子序列问题的描述：给定两个序列X = {x1, x2, …, xm}, Y = {y1, y2, …, yn}, 求X和Y的最长公共子序列。 下面举个例子说明一下，X = {A,B,C,B,D,A,B},Y = {B,D,C,A,B,A}，那么他们的最长公共子序列为{B,C,B,A}. 最长公共子序列具有最优子结构的性质。设序列X和Y的最长公共子序列为Z={z1,z2,…,zk} ，则有 (1)若[latex]x_m=y_n，则z_k=x_m=y_n[/latex]，且[latex]Z_{k-1}[/latex]是[latex]X_{m-1}和Y_{n-1}[/latex]的最长公共子序列。 (2)若[latex]x_m≠y_n且z_k≠x_m[/latex]，则[latex]Z[/latex]是[latex]X_{m-1}[/latex]和[latex]Y[/latex]的最长公共子序列。 同理既然 (3)若[latex]x_m≠y_n且zk≠yn[/latex]，则[latex]Z[/latex]是[latex]X[/latex]和[latex]Y_{n-1}[/latex]的最长公共子序列。 对于(1),因为既然是最长公共子序列，若[latex]z_k不取x_m[/latex],那就不是最长了，形成矛盾。而当X,Y均去掉这个相等的元素后，明显[latex]Z_{k-1}[/latex]，即去掉该元素的Z，为剩下的X,Y的LCS. 对于(2)，既然[latex]z_k≠x_m[/latex]，那么X去掉[latex]x_m[/latex]也不会影响LCS.对于(3)同理。 这三条合起来，说明了两个序列的LCS包含了这个两个序列前缀的LCS，即LCS问题有最优子结构。具体在这里就是Z里一定包含有X,Y前缀的LCS。(若X为{A,B,C},X的所有前缀为{A},{A,B},{A,B,C}) 因为已经知道其最优子结构的特点，定义c[i][j]为[latex]X_i, Y_j[/latex]的LCS的长度，我们可以设计以下递归关系来求解 $$ c[i][j]=\left\{ \begin{array}{lcl} 0 &amp; &amp; {i = 0, j = 0}\\ c[i-1][j-1]+1 &amp; &amp; {i,j &gt; 0; x_i = x_j}\\ max(c[i][j-1], c[i-1][j]) &amp; &amp; {i,j &gt; 0; x_i \not= x_j} \end{array} \right. $$ 当i = 0, j = 0 时，X,Y为空串，LCS长度为0；当[latex]x_i = x_j[/latex]时，由上述的性质(1)可得当前LCS为[latex]X_{m-1}[/latex]和[latex]Y_{n-1}[/latex]的LCS末尾添上一个x_m；当[latex]x_i \not= x_j[/latex]时，说明当前x和y不等，那么LCS一定和[latex]X_{m-1}，Y[/latex]所得到的LCS或者和[latex]Y_{n-1}，X[/latex]所得到的LCS相等。可以结合下面这张图来理解 <img src="http://fanyijie.net/wp-content/uploads/2016/06/lcs-300x283.png" alt="lcs"> 因为每进行一次递归都有i-1或j-1，所以算法复杂度为O(m + n).</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/knapsack-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/knapsack-problem/" itemprop="url">背包问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T15:56:49+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背包问题是在1978年由Merkel和Hellman提出的经典问题。它属于NP完全问题，在规模较小的时候可以用动态规划进行求解。 在说经典的背包问题前，我们先看一个简化的小数背包问题。已知一个容量大小为M重量的背包和n种物品，物品i的重量为[latex]w_i[/latex],假定物品i的一部分[latex]x_i[/latex]放入背包会得到[latex]v_i<em>x_i[/latex]这么大的收益，这里，[latex]0 &lt;= x_i &lt;= 1, v_i &gt; 0[/latex]。采用怎样的装包方法才会使装入背包的物品总效益最大？ 这里由于物品是可分的，所以我们直接贪心就可以求解。求出[latex]v_i/w_i[/latex]的值，然后优先放[latex]v_i/w_i[/latex]大的就行了。 现在加一个限制，如果物品不可分我们又应该采取怎样的策略呢？具体一点说，我们现在考虑这样的情况：对物品i只有两个选择，装入背包或者不装入背包，不能将i装入多次，也不能只装部分。这就是我们现在要说的0-1背包问题。 0-1背包问题是一个特殊的整数规划，用反证容易得到其最优子结构的特性。我们定义m(i, j)为背包容量为j, 前i件物品可选的最优值，则可得其转移方程为 $$ m(i, j)=\left\{ \begin{array}{lcl} max(m(i-1, j), m(i-1, j-w_i)+v_i) &amp; &amp; {j \ge w_i}\\ m(i-1, j) &amp; &amp; {0 \leq j \leq w_i} \end{array} \right. $$ 因为对于每一个物品i，若当前背包容量大于[latex]w_i[/latex]，那么就有两种选择：装入或者不装入，装入时即为[latex]m(i-1, j-w_i)+v_i)[/latex]，可选物品减少，背包容量也减少，背包价值增加；不装入时即为[latex]m(i-1, j)[/latex]，可选物品同样减少，由于未选所以背包价值不变，容量不变。我们取这两种选择中的最大值，即可保证该选择是当前最优的。若背包容量小于[latex]w_i[/latex]，那么就只能不选i物品了，和没选该物品的情况是一样的。只要我们保证每一次选择是当前最优的，根据最优子结构的性质，最后的最终结果m[n][c]即为问题最优解。 根据m(i, j)定义可知边界值如下 $$ m(1, j) = \left\{\begin{array} vv_1 &amp; &amp; {j \ge w_1}\\ 0 &amp; &amp; {0 \le j &lt; w_1} \end{array} \right. $$ 根据转移方程，我们可以看出算法的时间复杂度[latex] T(n) = O(n\</em>c)[/latex],空间复杂度为同样为[latex]T(n) = O(n*c)[/latex].但是如果仔细观察递归表的话，可以发现这个算法在空间上还可以进行优化。可以巧妙的利用循环的顺序，使得第i次循环结束后的m(j)就就是之前的m(i, j)，这样最后只要输出m[c]就可以了，将空间复杂度优化到了[latex] O(C)[/latex]. 则此时的转移方程为 $$ m(j) =\left\{ \begin{array}{lcl} max(m(j), m((j - w_i) + v_i) &amp; &amp; {j \ge w_i}\\ m(j) &amp; &amp; {0 \leq j \leq w_i} \end{array} \right. $$ 注意此时的循环应该是外循环i从1到n，然后内循环j从c到wi逆序遍历。 未完待续</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/matrix-chain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/matrix-chain/" itemprop="url">矩阵连乘</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T14:16:21+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>矩阵连乘是一个经典的动态规划问题。例如给定三个矩阵{A1,A2,A3},以及这三个矩阵的维数{10，100，5，50}，表示A1矩阵为10*100，A2为100*5，A3为5*50，那么他们相乘有两种方式，一种是((A1*A2)*A3),由矩阵乘法的标准算法，可知这样共需10*100*5 + 10*5*50 = 7500次数乘.另一种是(A1*(A2*A3)),需10*5*50 + 10*100*50 = 75000次数乘。所以加括号的方法对于计算量的影响是很大的。 现在我们的问题就是，对于一个给定合法连乘积A1*A2<em>…\</em>An，怎么求出其计算量最小的乘法次序。 为方便起见，我们记Ai*…*Aj为A[i, j], 记第i个矩阵的维数为Pi-1*Pi。首先观察到, 如果整个A[1，n]的计算次序最优，那么A[1, k]和A[k+1, n]的计算次序也是最优的。对这点可以反证，如果有比现在的A[1, k]更优的次序，则用该次序替换现在的次序，得到的新的A[1, n]也将更优，所以推出矛盾。这证明了该问题是满足最优子结构的。 下面我们再观察其是否具有重叠子问题的特性。定义m[i, j]为计算A[i, j]所需要的最小计算量，则原问题最优解为m[1, n]，根据矩阵连乘的特性，容易写出转移方程为 [latex]M[i][j] = min( m[i][k] + m[k+1][j] + P_{i-1} <em> P_k</em>P_j )[/latex] 其中i&lt;=k&lt;j, 且边界为i = j时m[i][j] = 0(此时为单个矩阵，计算量为0)。如果我们直接按照这个式子自顶向下，也就是从m[1][n]向下递归，那么明显将有大量的重复计算，因为不同的子问题个数最多为[latex]C^2_n + n = \theta(n^2)[/latex]个，而递归时计算是指数增长的。如果画出递归关系图，你可以更清晰的发现这种重叠子问题的特性。 于是我们可以发现，动态规划最基本的两个要素——最优子结构，重叠子问题，矩阵连乘都满足了，下面我们就用动态规划来解决这个问题吧。这里增加一个S数组作为最优解的记录。首先给自底向上的动规代码如下</p>
<p>#include<cstdio><br>using namespace std;<br>const int N = 10;<br>int p[7] = {30, 35, 15, 5, 10, 20, 25};<br>int m[N][N];<br>int s[N][N];<br>void MatrixChain(int n) {<br>    for(int i = 1; i &lt;= n; i++) {//边界初始化<br>        m[i][i] = 0;<br>    }<br>    for(int r = 2; r &lt;= n; r++) {//r代表当前矩阵连乘序列的长度<br>        for(int i = 1; i &lt;= n - r + 1; i++) { //i代表矩阵连乘序列的起始位置<br>            int j = i + r - 1; //j代表矩阵连乘序列的最终位置<br>            m[i][j] = m[i+1][j] + p[i-1] <em> p[i] </em> p[j]; //m[i][i] = 0 所以可以省略<br>            s[i][j] = i;<br>            for(int k = i + 1; k &lt; j; k++) {<br>                int t = m[i][k] + m[k+1][j] + p[i-1] <em> p[k] </em> p[j];//转移方程<br>                if(t &lt; m[i][j]) {<br>                    m[i][j] = t;<br>                    s[i][j] = k;//记录括号位置<br>                }<br>            }<br>        }<br>    }<br>}<br>void Traceback(int i,int j) {<br>    if(i == j) return;<br>    Traceback(i, s[i][j]);//递归打印k和k左边的<br>    Traceback(s[i][j] + 1, j);//递归打印k右边的<br>    printf(“Mutiply A%d,%d and A%d,%d\n”, i, s[i][j], s[i][j]+1, j);<br>}<br>int main(){<br>    MatrixChain(6);<br>    for(int i = 1; i &lt; 7; i++){<br>        for(int j = 1; j &lt; 7; j++){<br>            if( i &gt; j){<br>                printf(“    “);<br>            }<br>            else<br>            printf(“%-8d”, m[i][j]);<br>        }<br>        printf(“\n”);<br>    }<br>    printf(“%d\n”, m[1][6]);<br>    Traceback(1, 6);<br>}</cstdio></p>
<p>运行结果如下</p>
<p>0       15750   7875    9375    11875   15125<br>        0       2625    4375    7125    10500<br>                0       750     2500    5375<br>                        0       1000    3500<br>                                0       5000<br>                                        0<br>15125<br>Mutiply A2,2 and A3,3<br>Mutiply A1,1 and A2,3<br>Mutiply A4,4 and A5,5<br>Mutiply A4,5 and A6,6<br>Mutiply A1,3 and A4,6</p>
<p>可以看到右上角就是我们的答案，对角线的0就是我们的初始边界，然后以此为基础，每次沿主对角线向右下方向进行计算，由于每次计算都只需要用到该位置左边和下边的m[i][j]，而按照我们循环的方向，这些值都已经计算过了，所以直接使用这些值就可以了。这就是自底向上的循环递归。 此外还可以使用备忘录方法进行递归，也就是所说的记忆式搜索，每次将计算过的m储存起来，还是像最开始所说的那样自顶向下进行递归，但是如果遇到该m已经计算过，那么就把它直接返回而不进行重复计算。代码如下</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring><br>using namespace std;<br>const int N = 10;<br>int p[7] = {30, 35, 15, 5, 10, 20, 25};<br>int m[N][N];<br>int s[N][N];<br>int lookupChain(int i, int j){<br>    if(m[i][j] &gt; 0) {//如果已经计算过(!0)则直接返回该值<br>        return m[i][j];<br>    }<br>    if(i == j){//注意递归边界<br>        return 0;<br>    }<br>    int u = lookupChain(i, i) + lookupChain(i+1, j) + p[i-1]*p[i]*p[j];//状态转移方程，递归调用<br>    s[i][j] = i;<br>    for(int k = i + 1; k &lt; j; k++){<br>        int t = lookupChain(i, k) + lookupChain(k+1, j) + p[i-1]*p[k]*p[j];//状态转移方程，递归调用<br>        if(t &lt; u) {<br>            u = t;<br>            s[i][j] = k;<br>        }<br>    }<br>    m[i][j] = u;<br>    return u;<br>}<br>int MemorizedMatrixChain(int n) {<br>    memset(m, 0, sizeof(m)); //如果以后要重复调用，则需要初始化<br>    return lookupChain(1, n);<br>}<br>void Traceback(int i,int j) {<br>    if(i == j) return;<br>    Traceback(i, s[i][j]);<br>    Traceback(s[i][j] + 1, j);<br>    printf(“Mutiply A%d,%d and A%d,%d\n”, i, s[i][j], s[i][j]+1, j);<br>}<br>int main(){<br>    MemorizedMatrixChain(6);<br>    for(int i = 1; i &lt; 7; i++){<br>        for(int j = 1; j &lt; 7; j++){<br>            if( i &gt; j){<br>                printf(“    “);<br>            }<br>            else<br>            printf(“%-8d”, m[i][j]);<br>        }<br>        printf(“\n”);<br>    }<br>    printf(“%d\n”, m[1][6]);<br>    Traceback(1, 6);<br>}</cstring></p>
<p>备忘录算法与自底而上的循环算法一样，都是[latex]O(N^3)[/latex]的，其区别在于如果子问题空间中的部分子问题可以不用求解时，用备忘录方法比较好，因为该方法只求解那些确实需要求解的子问题。而对于每个子问题都至少要求解一次时，自底而上的动规因为只需要循环即可实现，应该会更好一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/24/quick-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/24/quick-sort/" itemprop="url">快速排序</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-24T18:20:36+08:00">
                2016-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分治/" itemprop="url" rel="index">
                    <span itemprop="name">分治</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>快排和归并排序一样，也是基于分治的算法。它的特点在于引入了基准数，在Θ(n)内将数组划分为3段，左段元素均小于中段(基准数），右端元素均大于中段(基准数），这样对左右段分别递归下去，直到每段长度为1为止。可以如下表示</p>
<pre><code>        \[4 3 5 2 6 7 1\]
         以4为基准划分    
  \[2 3 1\]     \[4\]       \[6 7 5\]
 以2为基准             以6为基准 
\[1\] \[2\] \[3\]   \[4\]     \[5\] \[6\] \[7\]
</code></pre><p>可以看到每次划分后，基准数左边的都比基准数小，基准数右边的都比基准数大，划分到长度为1时，排序也就完成了。 具体的划分方法一般采用双游标法。为方便起见左侧游标命名为low，右侧命名为high。 如上面例子中，首先取左边第一个为基准数，然后两个游标的初始位置分布在数组最左边和最右边。我们将基准数存储到pivot变量中，这样left位置就可以被赋值了。我们先从右侧游标开始，让其向左移动，直到游标当前所在数比基准数小才停下，因为我们想让右侧数均大于基准数。然后就可以把这个数直接赋给low所在的left位置，这样就符合我们的期望了。接着我们让左侧游标向右移动，同理当比基准大时就把这个数赋给high所在位置，因为high在上一次中已经把自己的值放到合适的地方去了，所以不用担心覆盖的问题。这样又多一个数符合我们的期望了。就这样一直循环直到low == high时，说明已经把整个数组都处理完了，因为low和high要相等必定已经有一个指针走到了该位置并做了交换了，所以直接将pivot放到low或high的位置让其归位即可。为什么说是归位呢，因为左边都比你大，右边都比你小，所以这个位置就是基准数真正所在的位置。 用一段简略的图文说明一下刚刚所说的划分方法，这里i就是之前说的low游标，j就是high游标</p>
<p> i       j<br>[4 7 5 2 3] 4<br>j所在3比4小</p>
<p> i       j<br>[3 7 5 2  ] 4<br>3移到i处 </p>
<p>   i     j<br>[3 7 5 2  ] 4<br>i++，i所在7比4大 </p>
<p>   i     j<br>[3   5 2 7] 4<br>7移到j处 </p>
<p>   i   j<br>[3   5 2 7] 4<br>j–,j所在2比4小</p>
<p>   i   j<br>[3 2 5   7] 4<br>2移到i处</p>
<pre><code>i j
</code></pre><p>[3 2 5   7] 4<br>i++, i所在5比4大</p>
<pre><code>i j
</code></pre><p>[3 2   5 7] 4<br>5移到j处</p>
<pre><code>ij
</code></pre><p>[3 2   5 7] 4<br>j–,i == j, 循环终止</p>
<p>[3 2 4 5 7]<br>将基准数4归位，然后对[3 2]和[5 7]进行下一次划分 </p>
<p>这样应该就比较形象了。 实现代码如下</p>
<p>#include<iostream><br>using namespace std;<br>void quick_sort(int a[], int left, int right){<br>    if(left &lt; right){<br>        int pivot = a[left];//这里取左侧第一个为基准<br>        int low = left;<br>        int high = right;<br>        while(low &lt; high){<br>            //从右往左走<br>            while(low &lt; high &amp;&amp; a[high] &gt;= pivot){//右侧游标小于基准时停下<br>                high–;<br>            }<br>            a[low]  = a[high];//将右侧游标放到左边，由于low处已被存储，所以直接赋值即可<br>            //从左往右走<br>            while(low &lt; high &amp;&amp; a[low] &lt;= pivot){//左侧游标大于基准时停下<br>                low ++;<br>            }<br>            a[high] = a[low];//将左侧游标放到右边，由于high处已被存储，所以直接赋值即可<br>        }<br>        a[low] = pivot;//基准数归位，基准数左边的都已经比基准小，右边都已经比基准大<br>        quick_sort(a, left, low - 1);    //继续递归处理左边的<br>        quick_sort(a, low + 1, right);    //继续递归处理右边的<br>    }<br>}<br>int main(){<br>    int a[10] = {3,1,2,7,8,9,5,6,4,12};<br>    quick_sort(a, 0, 9);<br>        for(int i = 0; i &lt; 10; i++){<br>        cout &lt;&lt; a[i];<br>    }<br>}</iostream></p>
<p>快排最好的情况就是每次划分产生的区间大小都为n/2, 容易知道这时的时间复杂度T(n) = 2*T(n/2) + Θ(n)，由主定理知T(n) = O(n*logn).而最坏的情况就是原序列有序，这样每次需要比较n-1, n-2, …, 1次，这时的T(n) = n*(n-1)/2 = O(n^2). 对于长序列来说，快排的平均效率是很高的，也是应用最广泛的排序算法。针对快排基准数(轴)的选取，还有短序列的情况，还可以做一些优化和改进。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/24/merge-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/24/merge-sort/" itemprop="url">归并排序</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-24T15:49:18+08:00">
                2016-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分治/" itemprop="url" rel="index">
                    <span itemprop="name">分治</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>归并排序是经典的分治算法，我对它的理解就是将数组不断分成两半，分解到最后数组只剩一个元素后开始将相邻的数组两两合并，每次合并都在相邻有序数组的基础上进行，并得到新的有序数组，直到最终得到整个有序数组。可以如下表示</p>
<p>分解<br>    [8 4 5 6 2 1 7 3]<br>    [8 4 5 6] [2 1 7 3]<br>    [8 4] [5 6] [2 1] [7 3]<br>    [8] [4] [5] [6] [2] [1] [7] [3]<br>合并<br>    [4 8] [5 6] [1 2] [3 7]<br>    [4 5 6 8] [1 2 3 7]<br>    [1 2 3 4 5 6 7 8]</p>
<p>从上也可以看出过程分为两步，第一步不断分半，第二部用合成两个有序数组的方法进行两两合并。 实现代码如下，参考<a href="http://blog.csdn.net/morewindows/article/details/6678165/" target="_blank" rel="noopener">MoreWindows</a>的博客</p>
<p>#include<iostream><br>using namespace std;<br>void merge(int a[], int first, int mid, int last, int temp[]){ //合成两个有序数组为一个有序数组<br>    int i = first, j = mid + 1;<br>    int m = mid, n = last;<br>    int k = 0;<br>    //这里相当于first到mid为一个有序数组，mid+1到last为另一个有序数组，然后将两个有序数组合并为一个有序数组<br>    while(i &lt;= m &amp;&amp; j &lt;= n){<br>        if (a[i] &lt;= a[j]) temp[k++] = a[i++];<br>        else temp[k++] = a[j++];<br>    }<br>    while(i &lt;= m){<br>        temp[k++] = a[i++];<br>    }<br>    while(j &lt;= n){<br>        temp[k++] = a[j++];<br>    }<br>    //把合并后的temp放回a中<br>    for(i = 0; i &lt; k; i++){<br>        a[first + i] = temp[i];<br>    }<br>}<br>void merge_sort(int a[], int first, int last, int temp[]){<br>    if(first &lt; last) {<br>        int mid = (first + last) / 2;<br>        merge_sort(a, first, mid ,temp); //处理mid以及mid左边的内容<br>        merge_sort(a, mid + 1, last, temp); //处理mid右边的内容<br>        merge(a, first, mid, last, temp);    //合并两个相邻的有序数列<br>    }<br>}<br>bool MergeSort(int a[], int n){//函数封装<br>    int *p = new int[n];<br>    if(p == NULL){<br>        return false;<br>    }<br>    merge_sort(a, 0, n-1, p);<br>    delete[] p;<br>    return true;<br>}<br>int main(){<br>    int a[10] = {3,1,2,7,8,9,5,6,4,0};<br>    MergeSort(a, 10);<br>    for(int i = 0; i &lt; 10; i++){<br>        cout &lt;&lt; a[i];<br>    }<br>}</iostream></p>
<p>因为两个有序数组的排序以及复制是O(n)的，则算法复杂度T(n) = 2<em>T(n/2) + O(n)，由<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">主定理</a>可知，T(n) = Θ(n</em>logn) 相比快排与堆排，归并排序最大的好处应该是它的稳定性，不会改变相等元素之间的顺序。对于总体无序但是局部相对有序的数组排序，或者是要求稳定性的排序，都是可以使用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/15/poj-1455-crazy-tea-party/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/15/poj-1455-crazy-tea-party/" itemprop="url">POJ 1455 Crazy tea party</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-15T18:09:57+08:00">
                2016-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/" itemprop="url" rel="index">
                    <span itemprop="name">A题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>POJ 1455 Crazy tea party</strong> <strong>Description</strong> n participants of &lt;&lt; crazy tea party &gt;&gt; sit around the table. Each minute one pair of neighbors can change their places. Find the minimum time (in minutes) required for all participants to sit in reverse order (so that left neighbors would become right, and right - left). <strong>Input</strong> The first line is the amount of tests. Each next line contains one integer n (1 &lt;= n &lt;= 32767) - the amount of crazy tea participants. <strong>Output</strong> For each number n of participants to crazy tea party print on the standard output, on a separate line, the minimum time required for all participants to sit in reverse order. <strong>Sample Input</strong> 3 4 5 6 <strong>Sample Output</strong> 2 4 6 <strong>Source</strong> Southeastern Europe 2003 题意：n个人围坐一圈，每分钟只能交换相邻两人位置，求逆序所需时间。 思路：先看对1到n的排列直接用交换相邻方法逆序，易得需要n*(n - 1)/2的时间，这里有环，可以把整个排列分成两部分来分别逆序，如 1 2 3 4 5 6，分为1 2 3 和 4 5 6， 分别逆序为 3 2 1和 6 5 4，合并起来 3 2 1 6 5 4 则构成一个逆序环。根据排列逆序时间，易知取中间分开时时间和最小。则对于偶数n，取两边人数均为n/2即可；对于奇数n， 取一边为n/2 另一边为 n/2 + 1即可。最后加起来则为最小时间。 ac代码：</p>
<p>#include<iostream><br>using namespace std;<br>int main(){<br>    int n;<br>    cin &gt;&gt; n;<br>    while(n–){<br>        int a;<br>        cin &gt;&gt; a;<br>        int n, m;<br>        if(a &amp; 1){<br>            n = a / 2;<br>            m = n + 1;<br>        }<br>        else{<br>            n = m = a / 2;<br>        }<br>        cout &lt;&lt; n<em>(n - 1) / 2 + m </em>(m -1)/2 &lt;&lt; endl;<br>    }<br>}</iostream></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/15/poj-2975-nim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/15/poj-2975-nim/" itemprop="url">POJ 2975 Nim</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-15T16:42:08+08:00">
                2016-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/" itemprop="url" rel="index">
                    <span itemprop="name">A题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>POJ 2975 Nim</strong> <strong>Description</strong> Nim is a 2-player game featuring several piles of stones. Players alternate turns, and on his/her turn, a player’s move consists of removing one or more stones from any single pile. Play ends when all the stones have been removed, at which point the last player to have moved is declared the winner. Given a position in Nim, your task is to determine how many winning moves there are in that position. A position in Nim is called “losing” if the first player to move from that position would lose if both sides played perfectly. A “winning move,” then, is a move that leaves the game in a losing position. There is a famous theorem that classifies all losing positions. Suppose a Nim position contains n piles having k1, k2, …, kn stones respectively; in such a position, there are k1 + k2 + … + kn possible moves. We write each ki in binary (base 2). Then, the Nim position is losing if and only if, among all the ki’s, there are an even number of 1’s in each digit position. In other words, the Nim position is losing if and only if the xor of the ki’s is 0. Consider the position with three piles given by k1 = 7, k2 = 11, and k3 = 13. In binary, these values are as follows: 111 1011 1101 There are an odd number of 1’s among the rightmost digits, so this position is not losing. However, suppose k3 were changed to be 12. Then, there would be exactly two 1’s in each digit position, and thus, the Nim position would become losing. Since a winning move is any move that leaves the game in a losing position, it follows that removing one stone from the third pile is a winning move when k1 = 7, k2 = 11, and k3 = 13. In fact, there are exactly three winning moves from this position: namely removing one stone from any of the three piles. <strong>Input</strong> The input test file will contain multiple test cases, each of which begins with a line indicating the number of piles, 1 ≤ n ≤ 1000. On the next line, there are n positive integers, 1 ≤ ki ≤ 1, 000, 000, 000, indicating the number of stones in each pile. The end-of-file is marked by a test case with n = 0 and should not be processed. <strong>Output</strong> For each test case, write a single line with an integer indicating the number of winning moves from the given Nim position. <strong>Sample Input</strong> 3 7 11 13 2 1000000000 1000000000 0 <strong>Sample Output</strong> 3 0 <strong>Source</strong> Stanford Local 2005 题意：组合数学的一道经典习题，有K堆硬币，两人交替取子，每人在一次取子时只能取一堆中的硬币，取至少一枚，至多全部。最后所有堆变为空堆时游戏结束，最后取子的人获胜。 给定了每堆的子数，要求输出先手者有多少种必胜策略。 思路：根据组合数学知识，若每堆硬币数异或和为0，则先手必输。若不为0，则先手有必胜策略。具体策略数枚举求得。 当枚举到第i堆硬币，若除第i堆硬币外的其他硬币异或和为x，当第i堆硬币数量a[i]大于x时，说明 1.a[i] != x, 总异或和不等于0，有必胜策略。 2.可通过从a[i]中取出一定的硬币使得总异或和为0. (若a[i]&lt;x则不满足上述第2条) 则此时策略数加1，可通过第i堆实现winner move，让对手进入losing position.如此枚举所有堆即得结果。 ac代码：</p>
<p>#include<iostream><br>using namespace std;<br>int main(){<br>    long n, a[1001];<br>    while(cin &gt;&gt; n &amp;&amp; n){<br>        for(int i = 0; i &lt; n; i++){<br>            cin &gt;&gt; a[i];<br>        }<br>        int cnt = 0;<br>        for(int i = 0; i &lt; n; i++){<br>            int sum = 0;<br>            for(int j = 0; j &lt; n; j++){<br>                if(i != j){<br>                    sum^=a[j];<br>                }<br>            }<br>            if(a[i] &gt; sum){<br>                    cnt++;<br>            }<br>        }<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    }<br>}</iostream></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Fan Yijie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fan31415" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fanyije@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fan Yijie</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
