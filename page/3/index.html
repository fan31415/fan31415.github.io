<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo-32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo-16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.ong?v=5.1.4" color="#222">





  <meta name="keywords" content="fanyijie, technology" />










<meta property="og:type" content="website">
<meta property="og:title" content="Fan&#39;s Home">
<meta property="og:url" content="https://fanyijie.net/page/3/index.html">
<meta property="og:site_name" content="Fan&#39;s Home">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fan&#39;s Home">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fanyijie.net/page/3/"/>





  <title>Fan's Home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fan's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/knapsack-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/knapsack-problem/" itemprop="url">背包问题</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T15:56:49+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背包问题是在1978年由Merkel和Hellman提出的经典问题。它属于NP完全问题，在规模较小的时候可以用动态规划进行求解。 在说经典的背包问题前，我们先看一个简化的小数背包问题。已知一个容量大小为M重量的背包和n种物品，物品i的重量为[latex]w_i[/latex],假定物品i的一部分[latex]x_i[/latex]放入背包会得到[latex]v_i<em>x_i[/latex]这么大的收益，这里，[latex]0 &lt;= x_i &lt;= 1, v_i &gt; 0[/latex]。采用怎样的装包方法才会使装入背包的物品总效益最大？ 这里由于物品是可分的，所以我们直接贪心就可以求解。求出[latex]v_i/w_i[/latex]的值，然后优先放[latex]v_i/w_i[/latex]大的就行了。 现在加一个限制，如果物品不可分我们又应该采取怎样的策略呢？具体一点说，我们现在考虑这样的情况：对物品i只有两个选择，装入背包或者不装入背包，不能将i装入多次，也不能只装部分。这就是我们现在要说的0-1背包问题。 0-1背包问题是一个特殊的整数规划，用反证容易得到其最优子结构的特性。我们定义m(i, j)为背包容量为j, 前i件物品可选的最优值，则可得其转移方程为 $$ m(i, j)=\left\{ \begin{array}{lcl} max(m(i-1, j), m(i-1, j-w_i)+v_i) &amp; &amp; {j \ge w_i}\\ m(i-1, j) &amp; &amp; {0 \leq j \leq w_i} \end{array} \right. $$ 因为对于每一个物品i，若当前背包容量大于[latex]w_i[/latex]，那么就有两种选择：装入或者不装入，装入时即为[latex]m(i-1, j-w_i)+v_i)[/latex]，可选物品减少，背包容量也减少，背包价值增加；不装入时即为[latex]m(i-1, j)[/latex]，可选物品同样减少，由于未选所以背包价值不变，容量不变。我们取这两种选择中的最大值，即可保证该选择是当前最优的。若背包容量小于[latex]w_i[/latex]，那么就只能不选i物品了，和没选该物品的情况是一样的。只要我们保证每一次选择是当前最优的，根据最优子结构的性质，最后的最终结果m[n][c]即为问题最优解。 根据m(i, j)定义可知边界值如下 $$ m(1, j) = \left\{\begin{array} vv_1 &amp; &amp; {j \ge w_1}\\ 0 &amp; &amp; {0 \le j &lt; w_1} \end{array} \right. $$ 根据转移方程，我们可以看出算法的时间复杂度[latex] T(n) = O(n\</em>c)[/latex],空间复杂度为同样为[latex]T(n) = O(n*c)[/latex].但是如果仔细观察递归表的话，可以发现这个算法在空间上还可以进行优化。可以巧妙的利用循环的顺序，使得第i次循环结束后的m(j)就就是之前的m(i, j)，这样最后只要输出m[c]就可以了，将空间复杂度优化到了[latex] O(C)[/latex]. 则此时的转移方程为 $$ m(j) =\left\{ \begin{array}{lcl} max(m(j), m((j - w_i) + v_i) &amp; &amp; {j \ge w_i}\\ m(j) &amp; &amp; {0 \leq j \leq w_i} \end{array} \right. $$ 注意此时的循环应该是外循环i从1到n，然后内循环j从c到wi逆序遍历。 未完待续</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/25/matrix-chain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/25/matrix-chain/" itemprop="url">矩阵连乘</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-25T14:16:21+08:00">
                2016-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/动态规划/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>矩阵连乘是一个经典的动态规划问题。例如给定三个矩阵{A1,A2,A3},以及这三个矩阵的维数{10，100，5，50}，表示A1矩阵为10*100，A2为100*5，A3为5*50，那么他们相乘有两种方式，一种是((A1*A2)*A3),由矩阵乘法的标准算法，可知这样共需10*100*5 + 10*5*50 = 7500次数乘.另一种是(A1*(A2*A3)),需10*5*50 + 10*100*50 = 75000次数乘。所以加括号的方法对于计算量的影响是很大的。 现在我们的问题就是，对于一个给定合法连乘积A1*A2<em>…\</em>An，怎么求出其计算量最小的乘法次序。 为方便起见，我们记Ai*…*Aj为A[i, j], 记第i个矩阵的维数为Pi-1*Pi。首先观察到, 如果整个A[1，n]的计算次序最优，那么A[1, k]和A[k+1, n]的计算次序也是最优的。对这点可以反证，如果有比现在的A[1, k]更优的次序，则用该次序替换现在的次序，得到的新的A[1, n]也将更优，所以推出矛盾。这证明了该问题是满足最优子结构的。 下面我们再观察其是否具有重叠子问题的特性。定义m[i, j]为计算A[i, j]所需要的最小计算量，则原问题最优解为m[1, n]，根据矩阵连乘的特性，容易写出转移方程为 [latex]M[i][j] = min( m[i][k] + m[k+1][j] + P_{i-1} <em> P_k</em>P_j )[/latex] 其中i&lt;=k&lt;j, 且边界为i = j时m[i][j] = 0(此时为单个矩阵，计算量为0)。如果我们直接按照这个式子自顶向下，也就是从m[1][n]向下递归，那么明显将有大量的重复计算，因为不同的子问题个数最多为[latex]C^2_n + n = \theta(n^2)[/latex]个，而递归时计算是指数增长的。如果画出递归关系图，你可以更清晰的发现这种重叠子问题的特性。 于是我们可以发现，动态规划最基本的两个要素——最优子结构，重叠子问题，矩阵连乘都满足了，下面我们就用动态规划来解决这个问题吧。这里增加一个S数组作为最优解的记录。首先给自底向上的动规代码如下</p>
<p>#include<cstdio><br>using namespace std;<br>const int N = 10;<br>int p[7] = {30, 35, 15, 5, 10, 20, 25};<br>int m[N][N];<br>int s[N][N];<br>void MatrixChain(int n) {<br>    for(int i = 1; i &lt;= n; i++) {//边界初始化<br>        m[i][i] = 0;<br>    }<br>    for(int r = 2; r &lt;= n; r++) {//r代表当前矩阵连乘序列的长度<br>        for(int i = 1; i &lt;= n - r + 1; i++) { //i代表矩阵连乘序列的起始位置<br>            int j = i + r - 1; //j代表矩阵连乘序列的最终位置<br>            m[i][j] = m[i+1][j] + p[i-1] <em> p[i] </em> p[j]; //m[i][i] = 0 所以可以省略<br>            s[i][j] = i;<br>            for(int k = i + 1; k &lt; j; k++) {<br>                int t = m[i][k] + m[k+1][j] + p[i-1] <em> p[k] </em> p[j];//转移方程<br>                if(t &lt; m[i][j]) {<br>                    m[i][j] = t;<br>                    s[i][j] = k;//记录括号位置<br>                }<br>            }<br>        }<br>    }<br>}<br>void Traceback(int i,int j) {<br>    if(i == j) return;<br>    Traceback(i, s[i][j]);//递归打印k和k左边的<br>    Traceback(s[i][j] + 1, j);//递归打印k右边的<br>    printf(“Mutiply A%d,%d and A%d,%d\n”, i, s[i][j], s[i][j]+1, j);<br>}<br>int main(){<br>    MatrixChain(6);<br>    for(int i = 1; i &lt; 7; i++){<br>        for(int j = 1; j &lt; 7; j++){<br>            if( i &gt; j){<br>                printf(“    “);<br>            }<br>            else<br>            printf(“%-8d”, m[i][j]);<br>        }<br>        printf(“\n”);<br>    }<br>    printf(“%d\n”, m[1][6]);<br>    Traceback(1, 6);<br>}</cstdio></p>
<p>运行结果如下</p>
<p>0       15750   7875    9375    11875   15125<br>        0       2625    4375    7125    10500<br>                0       750     2500    5375<br>                        0       1000    3500<br>                                0       5000<br>                                        0<br>15125<br>Mutiply A2,2 and A3,3<br>Mutiply A1,1 and A2,3<br>Mutiply A4,4 and A5,5<br>Mutiply A4,5 and A6,6<br>Mutiply A1,3 and A4,6</p>
<p>可以看到右上角就是我们的答案，对角线的0就是我们的初始边界，然后以此为基础，每次沿主对角线向右下方向进行计算，由于每次计算都只需要用到该位置左边和下边的m[i][j]，而按照我们循环的方向，这些值都已经计算过了，所以直接使用这些值就可以了。这就是自底向上的循环递归。 此外还可以使用备忘录方法进行递归，也就是所说的记忆式搜索，每次将计算过的m储存起来，还是像最开始所说的那样自顶向下进行递归，但是如果遇到该m已经计算过，那么就把它直接返回而不进行重复计算。代码如下</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring><br>using namespace std;<br>const int N = 10;<br>int p[7] = {30, 35, 15, 5, 10, 20, 25};<br>int m[N][N];<br>int s[N][N];<br>int lookupChain(int i, int j){<br>    if(m[i][j] &gt; 0) {//如果已经计算过(!0)则直接返回该值<br>        return m[i][j];<br>    }<br>    if(i == j){//注意递归边界<br>        return 0;<br>    }<br>    int u = lookupChain(i, i) + lookupChain(i+1, j) + p[i-1]*p[i]*p[j];//状态转移方程，递归调用<br>    s[i][j] = i;<br>    for(int k = i + 1; k &lt; j; k++){<br>        int t = lookupChain(i, k) + lookupChain(k+1, j) + p[i-1]*p[k]*p[j];//状态转移方程，递归调用<br>        if(t &lt; u) {<br>            u = t;<br>            s[i][j] = k;<br>        }<br>    }<br>    m[i][j] = u;<br>    return u;<br>}<br>int MemorizedMatrixChain(int n) {<br>    memset(m, 0, sizeof(m)); //如果以后要重复调用，则需要初始化<br>    return lookupChain(1, n);<br>}<br>void Traceback(int i,int j) {<br>    if(i == j) return;<br>    Traceback(i, s[i][j]);<br>    Traceback(s[i][j] + 1, j);<br>    printf(“Mutiply A%d,%d and A%d,%d\n”, i, s[i][j], s[i][j]+1, j);<br>}<br>int main(){<br>    MemorizedMatrixChain(6);<br>    for(int i = 1; i &lt; 7; i++){<br>        for(int j = 1; j &lt; 7; j++){<br>            if( i &gt; j){<br>                printf(“    “);<br>            }<br>            else<br>            printf(“%-8d”, m[i][j]);<br>        }<br>        printf(“\n”);<br>    }<br>    printf(“%d\n”, m[1][6]);<br>    Traceback(1, 6);<br>}</cstring></p>
<p>备忘录算法与自底而上的循环算法一样，都是[latex]O(N^3)[/latex]的，其区别在于如果子问题空间中的部分子问题可以不用求解时，用备忘录方法比较好，因为该方法只求解那些确实需要求解的子问题。而对于每个子问题都至少要求解一次时，自底而上的动规因为只需要循环即可实现，应该会更好一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/24/quick-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/24/quick-sort/" itemprop="url">快速排序</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-24T18:20:36+08:00">
                2016-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分治/" itemprop="url" rel="index">
                    <span itemprop="name">分治</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>快排和归并排序一样，也是基于分治的算法。它的特点在于引入了基准数，在Θ(n)内将数组划分为3段，左段元素均小于中段(基准数），右端元素均大于中段(基准数），这样对左右段分别递归下去，直到每段长度为1为止。可以如下表示</p>
<pre><code>        \[4 3 5 2 6 7 1\]
         以4为基准划分    
  \[2 3 1\]     \[4\]       \[6 7 5\]
 以2为基准             以6为基准 
\[1\] \[2\] \[3\]   \[4\]     \[5\] \[6\] \[7\]
</code></pre><p>可以看到每次划分后，基准数左边的都比基准数小，基准数右边的都比基准数大，划分到长度为1时，排序也就完成了。 具体的划分方法一般采用双游标法。为方便起见左侧游标命名为low，右侧命名为high。 如上面例子中，首先取左边第一个为基准数，然后两个游标的初始位置分布在数组最左边和最右边。我们将基准数存储到pivot变量中，这样left位置就可以被赋值了。我们先从右侧游标开始，让其向左移动，直到游标当前所在数比基准数小才停下，因为我们想让右侧数均大于基准数。然后就可以把这个数直接赋给low所在的left位置，这样就符合我们的期望了。接着我们让左侧游标向右移动，同理当比基准大时就把这个数赋给high所在位置，因为high在上一次中已经把自己的值放到合适的地方去了，所以不用担心覆盖的问题。这样又多一个数符合我们的期望了。就这样一直循环直到low == high时，说明已经把整个数组都处理完了，因为low和high要相等必定已经有一个指针走到了该位置并做了交换了，所以直接将pivot放到low或high的位置让其归位即可。为什么说是归位呢，因为左边都比你大，右边都比你小，所以这个位置就是基准数真正所在的位置。 用一段简略的图文说明一下刚刚所说的划分方法，这里i就是之前说的low游标，j就是high游标</p>
<p> i       j<br>[4 7 5 2 3] 4<br>j所在3比4小</p>
<p> i       j<br>[3 7 5 2  ] 4<br>3移到i处 </p>
<p>   i     j<br>[3 7 5 2  ] 4<br>i++，i所在7比4大 </p>
<p>   i     j<br>[3   5 2 7] 4<br>7移到j处 </p>
<p>   i   j<br>[3   5 2 7] 4<br>j–,j所在2比4小</p>
<p>   i   j<br>[3 2 5   7] 4<br>2移到i处</p>
<pre><code>i j
</code></pre><p>[3 2 5   7] 4<br>i++, i所在5比4大</p>
<pre><code>i j
</code></pre><p>[3 2   5 7] 4<br>5移到j处</p>
<pre><code>ij
</code></pre><p>[3 2   5 7] 4<br>j–,i == j, 循环终止</p>
<p>[3 2 4 5 7]<br>将基准数4归位，然后对[3 2]和[5 7]进行下一次划分 </p>
<p>这样应该就比较形象了。 实现代码如下</p>
<p>#include<iostream><br>using namespace std;<br>void quick_sort(int a[], int left, int right){<br>    if(left &lt; right){<br>        int pivot = a[left];//这里取左侧第一个为基准<br>        int low = left;<br>        int high = right;<br>        while(low &lt; high){<br>            //从右往左走<br>            while(low &lt; high &amp;&amp; a[high] &gt;= pivot){//右侧游标小于基准时停下<br>                high–;<br>            }<br>            a[low]  = a[high];//将右侧游标放到左边，由于low处已被存储，所以直接赋值即可<br>            //从左往右走<br>            while(low &lt; high &amp;&amp; a[low] &lt;= pivot){//左侧游标大于基准时停下<br>                low ++;<br>            }<br>            a[high] = a[low];//将左侧游标放到右边，由于high处已被存储，所以直接赋值即可<br>        }<br>        a[low] = pivot;//基准数归位，基准数左边的都已经比基准小，右边都已经比基准大<br>        quick_sort(a, left, low - 1);    //继续递归处理左边的<br>        quick_sort(a, low + 1, right);    //继续递归处理右边的<br>    }<br>}<br>int main(){<br>    int a[10] = {3,1,2,7,8,9,5,6,4,12};<br>    quick_sort(a, 0, 9);<br>        for(int i = 0; i &lt; 10; i++){<br>        cout &lt;&lt; a[i];<br>    }<br>}</iostream></p>
<p>快排最好的情况就是每次划分产生的区间大小都为n/2, 容易知道这时的时间复杂度T(n) = 2*T(n/2) + Θ(n)，由主定理知T(n) = O(n*logn).而最坏的情况就是原序列有序，这样每次需要比较n-1, n-2, …, 1次，这时的T(n) = n*(n-1)/2 = O(n^2). 对于长序列来说，快排的平均效率是很高的，也是应用最广泛的排序算法。针对快排基准数(轴)的选取，还有短序列的情况，还可以做一些优化和改进。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/24/merge-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/24/merge-sort/" itemprop="url">归并排序</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-24T15:49:18+08:00">
                2016-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分治/" itemprop="url" rel="index">
                    <span itemprop="name">分治</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>归并排序是经典的分治算法，我对它的理解就是将数组不断分成两半，分解到最后数组只剩一个元素后开始将相邻的数组两两合并，每次合并都在相邻有序数组的基础上进行，并得到新的有序数组，直到最终得到整个有序数组。可以如下表示</p>
<p>分解<br>    [8 4 5 6 2 1 7 3]<br>    [8 4 5 6] [2 1 7 3]<br>    [8 4] [5 6] [2 1] [7 3]<br>    [8] [4] [5] [6] [2] [1] [7] [3]<br>合并<br>    [4 8] [5 6] [1 2] [3 7]<br>    [4 5 6 8] [1 2 3 7]<br>    [1 2 3 4 5 6 7 8]</p>
<p>从上也可以看出过程分为两步，第一步不断分半，第二部用合成两个有序数组的方法进行两两合并。 实现代码如下，参考<a href="http://blog.csdn.net/morewindows/article/details/6678165/" target="_blank" rel="noopener">MoreWindows</a>的博客</p>
<p>#include<iostream><br>using namespace std;<br>void merge(int a[], int first, int mid, int last, int temp[]){ //合成两个有序数组为一个有序数组<br>    int i = first, j = mid + 1;<br>    int m = mid, n = last;<br>    int k = 0;<br>    //这里相当于first到mid为一个有序数组，mid+1到last为另一个有序数组，然后将两个有序数组合并为一个有序数组<br>    while(i &lt;= m &amp;&amp; j &lt;= n){<br>        if (a[i] &lt;= a[j]) temp[k++] = a[i++];<br>        else temp[k++] = a[j++];<br>    }<br>    while(i &lt;= m){<br>        temp[k++] = a[i++];<br>    }<br>    while(j &lt;= n){<br>        temp[k++] = a[j++];<br>    }<br>    //把合并后的temp放回a中<br>    for(i = 0; i &lt; k; i++){<br>        a[first + i] = temp[i];<br>    }<br>}<br>void merge_sort(int a[], int first, int last, int temp[]){<br>    if(first &lt; last) {<br>        int mid = (first + last) / 2;<br>        merge_sort(a, first, mid ,temp); //处理mid以及mid左边的内容<br>        merge_sort(a, mid + 1, last, temp); //处理mid右边的内容<br>        merge(a, first, mid, last, temp);    //合并两个相邻的有序数列<br>    }<br>}<br>bool MergeSort(int a[], int n){//函数封装<br>    int *p = new int[n];<br>    if(p == NULL){<br>        return false;<br>    }<br>    merge_sort(a, 0, n-1, p);<br>    delete[] p;<br>    return true;<br>}<br>int main(){<br>    int a[10] = {3,1,2,7,8,9,5,6,4,0};<br>    MergeSort(a, 10);<br>    for(int i = 0; i &lt; 10; i++){<br>        cout &lt;&lt; a[i];<br>    }<br>}</iostream></p>
<p>因为两个有序数组的排序以及复制是O(n)的，则算法复杂度T(n) = 2<em>T(n/2) + O(n)，由<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">主定理</a>可知，T(n) = Θ(n</em>logn) 相比快排与堆排，归并排序最大的好处应该是它的稳定性，不会改变相等元素之间的顺序。对于总体无序但是局部相对有序的数组排序，或者是要求稳定性的排序，都是可以使用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/15/poj-1455-crazy-tea-party/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/15/poj-1455-crazy-tea-party/" itemprop="url">POJ 1455 Crazy tea party</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-15T18:09:57+08:00">
                2016-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/" itemprop="url" rel="index">
                    <span itemprop="name">A题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>POJ 1455 Crazy tea party</strong> <strong>Description</strong> n participants of &lt;&lt; crazy tea party &gt;&gt; sit around the table. Each minute one pair of neighbors can change their places. Find the minimum time (in minutes) required for all participants to sit in reverse order (so that left neighbors would become right, and right - left). <strong>Input</strong> The first line is the amount of tests. Each next line contains one integer n (1 &lt;= n &lt;= 32767) - the amount of crazy tea participants. <strong>Output</strong> For each number n of participants to crazy tea party print on the standard output, on a separate line, the minimum time required for all participants to sit in reverse order. <strong>Sample Input</strong> 3 4 5 6 <strong>Sample Output</strong> 2 4 6 <strong>Source</strong> Southeastern Europe 2003 题意：n个人围坐一圈，每分钟只能交换相邻两人位置，求逆序所需时间。 思路：先看对1到n的排列直接用交换相邻方法逆序，易得需要n*(n - 1)/2的时间，这里有环，可以把整个排列分成两部分来分别逆序，如 1 2 3 4 5 6，分为1 2 3 和 4 5 6， 分别逆序为 3 2 1和 6 5 4，合并起来 3 2 1 6 5 4 则构成一个逆序环。根据排列逆序时间，易知取中间分开时时间和最小。则对于偶数n，取两边人数均为n/2即可；对于奇数n， 取一边为n/2 另一边为 n/2 + 1即可。最后加起来则为最小时间。 ac代码：</p>
<p>#include<iostream><br>using namespace std;<br>int main(){<br>    int n;<br>    cin &gt;&gt; n;<br>    while(n–){<br>        int a;<br>        cin &gt;&gt; a;<br>        int n, m;<br>        if(a &amp; 1){<br>            n = a / 2;<br>            m = n + 1;<br>        }<br>        else{<br>            n = m = a / 2;<br>        }<br>        cout &lt;&lt; n<em>(n - 1) / 2 + m </em>(m -1)/2 &lt;&lt; endl;<br>    }<br>}</iostream></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/06/15/poj-2975-nim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/15/poj-2975-nim/" itemprop="url">POJ 2975 Nim</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-15T16:42:08+08:00">
                2016-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/A题/" itemprop="url" rel="index">
                    <span itemprop="name">A题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>POJ 2975 Nim</strong> <strong>Description</strong> Nim is a 2-player game featuring several piles of stones. Players alternate turns, and on his/her turn, a player’s move consists of removing one or more stones from any single pile. Play ends when all the stones have been removed, at which point the last player to have moved is declared the winner. Given a position in Nim, your task is to determine how many winning moves there are in that position. A position in Nim is called “losing” if the first player to move from that position would lose if both sides played perfectly. A “winning move,” then, is a move that leaves the game in a losing position. There is a famous theorem that classifies all losing positions. Suppose a Nim position contains n piles having k1, k2, …, kn stones respectively; in such a position, there are k1 + k2 + … + kn possible moves. We write each ki in binary (base 2). Then, the Nim position is losing if and only if, among all the ki’s, there are an even number of 1’s in each digit position. In other words, the Nim position is losing if and only if the xor of the ki’s is 0. Consider the position with three piles given by k1 = 7, k2 = 11, and k3 = 13. In binary, these values are as follows: 111 1011 1101 There are an odd number of 1’s among the rightmost digits, so this position is not losing. However, suppose k3 were changed to be 12. Then, there would be exactly two 1’s in each digit position, and thus, the Nim position would become losing. Since a winning move is any move that leaves the game in a losing position, it follows that removing one stone from the third pile is a winning move when k1 = 7, k2 = 11, and k3 = 13. In fact, there are exactly three winning moves from this position: namely removing one stone from any of the three piles. <strong>Input</strong> The input test file will contain multiple test cases, each of which begins with a line indicating the number of piles, 1 ≤ n ≤ 1000. On the next line, there are n positive integers, 1 ≤ ki ≤ 1, 000, 000, 000, indicating the number of stones in each pile. The end-of-file is marked by a test case with n = 0 and should not be processed. <strong>Output</strong> For each test case, write a single line with an integer indicating the number of winning moves from the given Nim position. <strong>Sample Input</strong> 3 7 11 13 2 1000000000 1000000000 0 <strong>Sample Output</strong> 3 0 <strong>Source</strong> Stanford Local 2005 题意：组合数学的一道经典习题，有K堆硬币，两人交替取子，每人在一次取子时只能取一堆中的硬币，取至少一枚，至多全部。最后所有堆变为空堆时游戏结束，最后取子的人获胜。 给定了每堆的子数，要求输出先手者有多少种必胜策略。 思路：根据组合数学知识，若每堆硬币数异或和为0，则先手必输。若不为0，则先手有必胜策略。具体策略数枚举求得。 当枚举到第i堆硬币，若除第i堆硬币外的其他硬币异或和为x，当第i堆硬币数量a[i]大于x时，说明 1.a[i] != x, 总异或和不等于0，有必胜策略。 2.可通过从a[i]中取出一定的硬币使得总异或和为0. (若a[i]&lt;x则不满足上述第2条) 则此时策略数加1，可通过第i堆实现winner move，让对手进入losing position.如此枚举所有堆即得结果。 ac代码：</p>
<p>#include<iostream><br>using namespace std;<br>int main(){<br>    long n, a[1001];<br>    while(cin &gt;&gt; n &amp;&amp; n){<br>        for(int i = 0; i &lt; n; i++){<br>            cin &gt;&gt; a[i];<br>        }<br>        int cnt = 0;<br>        for(int i = 0; i &lt; n; i++){<br>            int sum = 0;<br>            for(int j = 0; j &lt; n; j++){<br>                if(i != j){<br>                    sum^=a[j];<br>                }<br>            }<br>            if(a[i] &gt; sum){<br>                    cnt++;<br>            }<br>        }<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    }<br>}</iostream></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/24/subset-enumeration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/24/subset-enumeration/" itemprop="url">枚举子集</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-24T15:31:03+08:00">
                2016-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/回溯/算法学习/" itemprop="url" rel="index">
                    <span itemprop="name">算法学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里我们讨论没有重复元素集合的非空子集枚举方法。 <strong>1.增量构造</strong> 最基本的想法就是像构造全排列那样，每次遍历所有当前可能向集合中添加的值，添加进去然后递归。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void add_subset(int n, int *A, int cur){<br>    for(int i = 0; i &lt; cur; i++){    //打印当前枚举到的集合<br>        cout&lt;&lt;A[i]&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>    int s;<br>    if(cur){    //确定当前可向集合中添加的元素的最小可能值<br>        s = A[cur-1] + 1;<br>    }else{<br>        s = 0;<br>    }<br>    for(int i = s; i &lt; n; i++){    //遍历当前所有可能取值，从当前最小可能值到集合最大值<br>        A[cur] = i;<br>        add_subset(n, A, cur+1);    //递归构造<br>    }<br>}<br>int main(){<br>    int A[99] = {0};<br>    int n;<br>    cin&gt;&gt;n;<br>    add_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0<br>0 1<br>0 1 2<br>0 2<br>1<br>1 2<br>2</p>
<p>这里我们把集合元素从0到n-1进行编号，输出中的一行代表其中一个子集中的各元素编号。 这个算法的解答树共有2^n个节点。 <strong>2.位向量构造</strong> 这里我们构造一个位向量A[i], A[i] = 1代表i出现在了子集中。这个算法很好理解，从cur = 0时开始构造子集，每一次递归只用考虑选第i个元素和不选第i个元素两种情况，递归n次即可包括2^n个子集的情况，当cur == n时则说明已经构造出了当前选择下的子集，打印输出即可。不过这个算法的解答树有2^(n+1) - 1个节点，因为每一个未完成的解也会占用一个节点。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void pos_subset(int n,int *A,int cur){<br>    if(cur == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(A[i]){<br>                cout&lt;&lt;i&lt;&lt;” “;<br>            }<br>        }<br>        cout&lt;&lt;endl;<br>        return;<br>    }<br>    A[cur] = 1;<br>    pos_subset(n, A, cur + 1);<br>    A[cur] = 0;<br>    pos_subset(n, A, cur +1);<br>}<br>int main(){<br>    int A[99]={0};<br>    int n;<br>    cin&gt;&gt;n;<br>    pos_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0 1 2<br>0 1<br>0 2<br>0<br>1 2<br>1<br>2</p>
<p>输出的定义同上。 <strong>3.二进制法</strong> 这里我们用一个二进制数来表示子集S，比如10111，即表示0,1,2,4号元素均在子集S中。也就是说，二进制数从右往左数第i位如果是1，那么该二进制数代表的集合中有元素i，0则没有。 按照这个定义，我们可以写出下面的代码来枚举子集：</p>
<p>#include<iostream><br>using namespace std;<br>void binary_subset(int n, int s){<br>    for(int i = 0; i &lt; n; i++){<br>        if(s &amp; (1 &lt;&lt; i)){<br>            cout&lt;&lt;i&lt;&lt;” “;<br>        }<br>    }<br>    cout&lt;&lt;endl;<br>}<br>int main(){<br>    int n, s;<br>    cin&gt;&gt;n;<br>    for(int i = 0; i &lt; (1 &lt;&lt; n); i++){<br>        binary_subset(n, i);<br>    } </iostream></p>
<p>}</p>
<p>测试输入：3 测试输出：</p>
<p>0<br>1<br>0 1<br>2<br>0 2<br>1 2<br>0 1 2</p>
<p>在main函数中我们枚举了子集对应的编码0到2^n-1,而binary_subset函数则负责打印编码的二进制形式所对应的子集。binary_subset函数其实就是将从右往左看子集编码的每一位是否是1，是1就打印出当前位代表的元素,和位向量法的打印是一个方法。 输出分析：输入3，然后main函数从0开始循环到2^3-1，首先是i=0，进入子集函数，s=0，无输出。main函数循环到1,子集函数1&amp;1为真，输出i=0。继续子集函数进来2=10(2)，仅第二位为1，说明该集合只取了元素1（我们从0开始编码)，于是输出该集合包含的元素1,。接着进来3=11(2)，该集合取了元素0和1，则输出0,1.以此类推直到最后循环到7=111（2),输出该集合0,1,2,至此就将含有三个元素的集合的2^n-1个非空子集枚举完了。 这里注意一下，二进制法用int存i的话，最多只能输出n=30时的集合的子集。因为int最大只有2^31-1. <strong>二进制法的一个更简洁的写法</strong> 这里先贴代码：</p>
<p>#include<iostream><br>using namespace std;<br>void print_subset(int i,int n){    //打印i的二进制形式所对应的集合的所有元素<br>    for(int j = 0; j &lt; n; j++){<br>            if(i &amp; 1&lt;&lt;j){<br>                cout &lt;&lt; j &lt;&lt;” “;<br>            }<br>        }<br>        cout &lt;&lt; endl;<br>}<br>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = n; i; i = (i - 1) &amp; n){<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>    }<br>}<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;    //输入一个数n，对应其二进制形式所代表的集合<br>    binary_subset(n);    //输出n对应集合的所有子集的编码以及每个子集中的元素 </iostream></p>
<p>}</p>
<p>其中的关键语句就只有一句</p>
<p>for(int i = n; i; i = (i - 1) &amp; n)</p>
<p>就是这句话完成了对n所代表集合的子集的枚举。而print_subset函数只是用来打印出枚举出的子集i的元素的。 这句话的关键在于i = (i - 1) &amp; n这儿，其实就是多了一个&amp;n来把n中为0的数位在自减中过滤掉了。举个栗子，输入11，即1011(2),那么这个集合含有元素0,1,3，我们做这个循环的更新，会依次得到如下的i ：</p>
<p>1011    //n的初始值，二进制形式 </p>
<p>1010    //第一次循环<br>1001    //第二次循环<br>1000    //…<br>0011<br>0010<br>0001    //当i为0000时集合为空</p>
<p>可以看出对应111,110,101,100,011,010,001. 下面可以看一下测试运行的结果，测试输入：11 测试输出：</p>
<p>11 :0 1 3<br>10 :1 3<br>9 :0 3<br>8 :3<br>3 :0 1<br>2 :1<br>1 :0</p>
<p>和我们之前分析的是一致的。 附上写法的<strong>正序版本</strong></p>
<p>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = 0; ; i = (i - n) &amp; n){    //正序<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>        if( i == n) break;<br>    }<br>}</p>
<p>输入：11 输出：</p>
<p>0 :<br>1 :0<br>2 :1<br>3 :0 1<br>8 :3<br>9 :0 3<br>10 :1 3<br>11 :0 1 3</p>
<p>另外注意当被枚举的集合n固定为2^n-1时，这样的写法就失去了意义，而退化到二进制法的情况，这时直接写</p>
<p>for(int i = 0; i &lt; (1&lt;&lt;n); i++)</p>
<p>从1到2^n-1遍历即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/23/uva-140-bandwidth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/23/uva-140-bandwidth/" itemprop="url">Uva 140 Bandwidth</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-23T22:18:50+08:00">
                2016-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva 140 Bandwidth</strong> Given a graph (V,E) where V is a set of nodes and E is a set of arcs in VxV, and an ordering on the elements in V, then the bandwidth of a node v is defined as the maximum distance in the ordering between v and any node to which it is connected in the graph. The bandwidth of the ordering is then defined as the maximum of the individual bandwidths. For example, consider the following graph: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img1.gif" alt="140img1"> This can be ordered in many ways, two of which are illustrated below: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img2-300x34.gif" alt="140img2"> For these orderings, the bandwidths of the nodes (in order) are 6, 6, 1, 4, 1, 1, 6, 6 giving an ordering bandwidth of 6, and 5, 3, 1, 4, 3, 5, 1, 4 giving an ordering bandwidth of 5. Write a program that will find the ordering of a graph that minimises the bandwidth. <strong>Input</strong> Input will consist of a series of graphs. Each graph will appear on a line by itself. The entire file will be terminated by a line consisting of a single #. For each graph, the input will consist of a series of records separated by <code>;&#39;. Each record will consist of a node name (a single upper case character in the the range \</code>A’ to `Z’), followed by a `:’ and at least one of its neighbours. The graph will contain no more than 8 nodes. <strong>Output</strong> Output will consist of one line for each graph, listing the ordering of the nodes followed by an arrow (-&gt;) and the bandwidth for that ordering. All items must be separated from their neighbours by exactly one space. If more than one ordering produces the same bandwidth, then choose the smallest in lexicographic ordering, that is the one that would appear first in an alphabetic listing. <strong>Sample input</strong> A:FB;B:GC;D:GC;F:AGH;E:HD # <strong>Sample output</strong> A B C F G D H E -&gt; 3 题意：输入一个无向图G，定义一个由图的顶点构成的排列P. 定义任意一个顶点i的带宽b(i), 为i顶点与其相邻顶点在排列P中的最远距离。取所有顶点的b(i)的最大值为整个图G的bandwidth. 要求输出一个让bandwidth最小的顶点排列并输出其bandwidth值. 思路：因为图顶点数&lt;=8, 排列数小于100000, 所以这里直接用的暴力枚举。首先读入一行数据，然后用strchr函数(返回字符串str中第一次出现字符ch时的指针，如果没有出现则返回NULL)对本次输入出现的字母进行编号。通过mapc数组得到从编号到字母的映射，通过id数组得到字母到其编号的映射。 然后遍历输入，直接用向量u，v储存所有相邻的顶点，在循环中，u反复存储当前顶点，而对应的v则存入其相邻顶点，直到分号输入为止。这样就将所有会用来计算带宽的点对对应的存入了u，v中。 最后通过c++自带的next_permutation函数按字典序生成全排列。先初始化最小字典序全排列，然后循环生成。 这道题除了暴力的做法，还可以回溯剪枝，而且显然更快。这儿先留着下次有时间再写。 ac代码：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring></cstring></p>
<p>#include<algorithm></algorithm></p>
<p>#include<cmath></cmath></p>
<p>#include<vector></vector></p>
<p>#define N 10<br>using namespace std;<br>char in[100];<br>char mapc[30];<br>int id[30];<br>vector<int> u, v;<br>int main(){<br>    while(~scanf(“%s”,&amp;in) &amp;&amp; in[0] != ‘#’){<br>        int p = 0, num = 0, flag = 0;<br>        for(char a = ‘A’; a &lt;= ‘Z’; a++){<br>            if(strchr(in, a) != NULL){<br>                mapc[num] = a;<br>                id[a] = num;<br>                num++;<br>            }<br>        }<br>        char ch;<br>        int len = strlen(in);<br>        for(int i = 0; i &lt; len; i++){<br>            if(in[i] == ‘:’){<br>                flag = 1;<br>            }<br>            if(!flag){<br>                ch = in[i];<br>            }<br>            if(flag &amp;&amp; in[i] != ‘:’){<br>                if(in[i] != ‘;’){<br>                    u.push_back(id[ch]);<br>                    v.push_back(id[in[i]]);<br>                }<br>                else{<br>                    flag = 0;<br>                }<br>            }</int></p>
<pre><code>    }
    int pa\[N\], ans\[N\], pos\[N\], bw = 0x3f3f3f3f;
    for(int i = 0; i &lt; num; i++){
        pa\[i\] = i;
    }
    do{
        for(int i = 0; i &lt; num; i++){
            pos\[pa\[i\]\] = i;
        } 
        int b = 0;
        for(int i = 0; i &lt; u.size(); i++){
            b = max(b, abs(pos\[u\[i\]\]-pos\[v\[i\]\]));
        }
        if(b &lt; bw){
            bw = b;
            memcpy(ans, pa, sizeof(pa));
        }
    }while(next_permutation(pa, pa + num));
    for(int i = 0; i &lt; num; i++){
        printf(&quot;%c &quot;, mapc\[ans\[i\]\]);
    }
    printf(&quot;-&gt; %d\\n&quot;, bw);
    u.clear();
    v.clear();
    memset(mapc, 0, sizeof(mapc));
    memset(in, 0, sizeof(in));
    memset(id, 0, sizeof(id));
}
return 0;
</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/18/uva-129-krypton-factor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/18/uva-129-krypton-factor/" itemprop="url">Uva 129 Krypton Factor</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-18T15:58:52+08:00">
                2016-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva 129 Krypton Factor</strong> You have been employed by the organisers of a Super Krypton Factor Contest in which contestants have very high mental and physical abilities. In one section of the contest the contestants are tested on their ability to recall a sequence of characters which has been read to them by the Quiz Master. Many of the contestants are very good at recognising patterns. Therefore, in order to add some difficulty to this test, the organisers have decided that sequences containing certain types of repeated subsequences should not be used. However, they do not wish to remove all subsequences that are repeated, since in that case no single character could be repeated. This in itself would make the problem too easy for the contestants. Instead it is decided to eliminate all sequences containing an occurrence of two adjoining identical subsequences. Sequences containing such an occurrence will be called ``easy’’. Other sequences will be called ``hard’’. For example, the sequence ABACBCBAD is easy, since it contains an adjoining repetition of the subsequence CB. Other examples of easy sequences are: BB ABCDACABCAB ABCDABCD Some examples of hard sequences are: D DC ABDAB CBABCBA <strong>Input and Output</strong> In order to provide the Quiz Master with a potentially unlimited source of questions you are asked to write a program that will read input lines that contain integers n and L (in that order), where n &gt; 0 and L is in the range 1 &lt;= L &lt;= 26 , and for each input line prints out the nth hard sequence (composed of letters drawn from the first L letters in the alphabet), in increasing alphabetical order (alphabetical ordering here corresponds to the normal ordering encountered in a dictionary), followed (on the next line) by the length of that sequence. The first sequence in this ordering is A. You may assume that for given n and L there do exist at least n hard sequences. For example, with L = 3, the first 7 hard sequences are: A AB ABA ABAC ABACA ABACAB ABACABA As each sequence is potentially very long, split it into groups of four (4) characters separated by a space. If there are more than 16 such groups, please start a new line for the 17th group. Therefore, if the integers 7 and 3 appear on an input line, the output lines produced should be ABAC ABA 7 Input is terminated by a line containing two zeroes. Your program may assume a maximum sequence length of 80. <strong>Sample Input</strong> 30 3 0 0 <strong>Sample Output</strong> ABAC ABCA CBAB CABA CABC ACBA CABA 28 题意：输入n和l,输出字典序第n小的hard串。 hard的定义是字符串中不包含相邻的重复子串。字符串由A, B, C,…,从A开始的l个字母构成。 思路：和生成全排列的方法类似，每次向当前位置尝试添加一个字母，如果该字母和之前已放置的字母冲突，则按字典序继续循环尝试放置下一个字母，直到不冲突的时候就放置进去并进入下一层（下一位置）的递归。 递归的边界条件在这里需要一个全局变量cnt来判断。由于每进一次递归，cnt都会++, 而一旦能进入一次递归，则说明已经又找到了一个hard串了，所以当cnt++ == n,即cnt == n时，正好是字典序第n小的hard串生成完成的时候。这时候也就是递归成功的边界条件了. 这里由于只要达到目标就不用继续搜索下去，所以在边界条件中有return 0,表示搜索成功，这样在上一层递归if(!dfs(cur+1)) return 0 中，就可以直接继续return 0跳过循环退出,然后一层层快速跳出递归，避免无用搜索。如果走到叶子节点也未找到解，就会执行最后的return 1返回父节点，然后继续循环遍历父节点剩下的儿子。如果儿子遍历完仍未找到解，则会继续返回上一层父节点，然后继续遍历深入，直到搜索完所有节点或者找到解为止。 这里取值i是否尝试成功的条件判断，是通过遍历了当前字符串长度cur+1范围内所有偶数长度的后缀，循环进行测试而得到的。 对于每一次的尝试取值i，检查所有偶数长度的后缀。每次检查当前2*j长度的后缀的前一半和后一半是否完全相同。如果有一个字符不同，则eq = 0并break，说明对于当前后缀是没有重复的，j++并对下一个后缀长度2*j再次测试。 如果测试完所有能取到的后缀长度后，均没有发现重复子串，则说明字符串是ok的，可以进入下一个位置的递归；而只要其中有一次发现了重复子串，则eq = 1，ok = 0，不是hard串，无法进入下一位置的递归，只能对当前位置的取值i继续按字典序进行循环尝试，直到将循环完毕返回父节点或找到解退出递归为止。 ac代码如下：</p>
<p>#include<cstdio><br>using namespace std;<br>int n, l, cnt;<br>int S[82];<br>int dfs(int cur){    //return 0 means solution has found<br>    if(cnt++ == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(i &amp;&amp; i % 64 == 0) printf(“\n”);<br>            else if(i &amp;&amp; i % 4 == 0) printf(“ “);<br>            printf(“%c”, ‘A’+S[i]);<br>        }<br>        printf(“\n%d\n”, cur);<br>        return 0;<br>    }<br>    for(int i = 0; i &lt; l; i++){<br>        S[cur] = i;<br>        bool ok = 1;<br>        for(int j = 1; j*2 &lt;= cur+1; j++){    //每添加一个数，就对所有后一半包含新数的后缀进行测试<br>            bool eq = 1;<br>            for(int k = 0; k &lt; j; k++){        //测试当前后缀长度下，后缀的前一半是否等于后一半<br>                if(S[cur-k] != S[cur-k-j]){    //对前一半和后一半的对应字符逐个比较<br>                    eq = 0;<br>                    break;<br>                }<br>            }<br>            if(eq){<br>                ok = 0;<br>                break;<br>            }<br>        }<br>        if(ok){<br>            if(!dfs(cur+1)){    // 如果已经找到解，则退出<br>                return 0;<br>            }<br>        }</cstdio></p>
<pre><code>}
return 1;
</code></pre><p>}<br>int main(){<br>    while(scanf(“%d%d”, &amp;n, &amp;l) == 2 &amp;&amp; n){<br>        cnt = 0;<br>        dfs(0);<br>    }<br>    return 0;<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fanyijie.net/2016/05/18/uva-524-prime-ring-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan Yijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fan's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/18/uva-524-prime-ring-problem/" itemprop="url">Uva 524 Prime Ring Problem</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-18T14:10:44+08:00">
                2016-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/" itemprop="url" rel="index">
                    <span itemprop="name">Uva</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/" itemprop="url" rel="index">
                    <span itemprop="name">回溯</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Uva/回溯/数论/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Uva 524 Prime Ring Problem</strong> A ring is composed of n (even number) circles as shown in diagram. Put natural numbers 1, 2, . . . , n into each circle separately, and the sum of numbers in two adjacent circles should be a prime. Note: the number of first circle should always be 1. <strong>Input</strong> n (0 &lt; n ≤ 16) <strong>Output</strong> The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements. You are to write a program that completes above process. <strong>Sample Input</strong> 6 8 <strong>Sample Output</strong> Case 1: 1 4 3 2 5 6 1 6 5 2 3 4 Case 2: 1 2 3 8 5 6 7 4 1 2 5 8 3 4 7 6 1 4 7 6 5 8 3 2 1 6 7 4 3 8 5 2 题意：生成一个素数环，使得相邻两个整数之和为素数，包括首尾。素数环由1~n组成，输出从1开始逆时针排列。 思路：和生成全排列的模型类似，直接递归深度优先遍历解答树，递归边界条件为cur == n且第一个数和最后一个数之和为素数，尝试取值的循环直接从2到n即可，因为要求从1开始输出，所以1每次直接加到输出数组第一个就行了。 尝试是否成功的判断条件就很简单了，一个通用的!vis[i] 和 !icp[i + A[cur-1]]，即i这个数没有被用到过且i和前一个放置的数之和为素数即可。这里素数的判定用的是先素数筛法生成素数表，然后直接用素数表判断的。 注意一下输出排列时，有一个if(i) printf(“ “)，以防止在一个排列最后同时输出空格与换行而PE. ac代码如下：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath></cmath></p>
<p>#include<cstring><br>using namespace std;<br>int n,A[99];<br>bool vis[99];<br>bool isc[101];<br>void get_prime(int n){<br>    int m=sqrt(n+0.5);<br>    for(int i = 2; i &lt;= m; i++){<br>        if(!isc[i]){<br>            for(int j = i*i; j &lt;= n; j+=i){<br>                isc[j] = 1;<br>            }<br>        }<br>    }<br>}<br>void dfs(int cur){<br>    if(cur == n &amp;&amp; !isc[A[0] + A[n-1]]){<br>        for(int i = 0; i &lt; n; i++){<br>            if(i) printf(“ “);<br>            printf(“%d”,A[i]);<br>        }<br>        printf(“\n”);<br>    }<br>    else for(int i = 2; i &lt;= n; i++){<br>        if(!vis[i] &amp;&amp; !isc[i+A[cur-1]]){<br>            A[cur] = i;<br>            vis[i] = 1;<br>            dfs(cur+1);<br>            vis[i] = 0;<br>        }<br>    }<br>}<br>int main(){<br>    get_prime(100);<br>    isc[0]=isc[1]=1;<br>    int kase = 0;<br>    while(~scanf(“%d”, &amp;n)){<br>        if(kase &gt; 0) printf(“\n”);<br>        printf(“Case %d:\n”, ++kase);<br>        memset(vis, 0, sizeof(vis));<br>        A[0] = 1;<br>        dfs(1);<br>    }<br>    return 0;<br>}</cstring></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Fan Yijie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/fan31415" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:fanyije@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fan Yijie</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
