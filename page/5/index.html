<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-poj-1455-crazy-tea-party-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/15/poj-1455-crazy-tea-party-1/" class="article-date">
  <time datetime="2016-06-15T10:09:57.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/A题/">A题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/poj-1455-crazy-tea-party-1/">POJ 1455 Crazy tea party</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>POJ 1455 Crazy tea party</strong> <strong>Description</strong> n participants of &lt;&lt; crazy tea party &gt;&gt; sit around the table. Each minute one pair of neighbors can change their places. Find the minimum time (in minutes) required for all participants to sit in reverse order (so that left neighbors would become right, and right - left). <strong>Input</strong> The first line is the amount of tests. Each next line contains one integer n (1 &lt;= n &lt;= 32767) - the amount of crazy tea participants. <strong>Output</strong> For each number n of participants to crazy tea party print on the standard output, on a separate line, the minimum time required for all participants to sit in reverse order. <strong>Sample Input</strong> 3 4 5 6 <strong>Sample Output</strong> 2 4 6 <strong>Source</strong> Southeastern Europe 2003 题意：n个人围坐一圈，每分钟只能交换相邻两人位置，求逆序所需时间。 思路：先看对1到n的排列直接用交换相邻方法逆序，易得需要n*(n - 1)/2的时间，这里有环，可以把整个排列分成两部分来分别逆序，如 1 2 3 4 5 6，分为1 2 3 和 4 5 6， 分别逆序为 3 2 1和 6 5 4，合并起来 3 2 1 6 5 4 则构成一个逆序环。根据排列逆序时间，易知取中间分开时时间和最小。则对于偶数n，取两边人数均为n/2即可；对于奇数n， 取一边为n/2 另一边为 n/2 + 1即可。最后加起来则为最小时间。 ac代码：</p>
<p>#include<iostream><br>using namespace std;<br>int main(){<br>    int n;<br>    cin &gt;&gt; n;<br>    while(n–){<br>        int a;<br>        cin &gt;&gt; a;<br>        int n, m;<br>        if(a &amp; 1){<br>            n = a / 2;<br>            m = n + 1;<br>        }<br>        else{<br>            n = m = a / 2;<br>        }<br>        cout &lt;&lt; n<em>(n - 1) / 2 + m </em>(m -1)/2 &lt;&lt; endl;<br>    }<br>}</iostream></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/15/poj-1455-crazy-tea-party-1/" data-id="cjkf4itxm001a272yqjfe2iwg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-poj-2975-nim" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/15/poj-2975-nim/" class="article-date">
  <time datetime="2016-06-15T08:42:08.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/A题/">A题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/poj-2975-nim/">POJ 2975 Nim</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>POJ 2975 Nim</strong> <strong>Description</strong> Nim is a 2-player game featuring several piles of stones. Players alternate turns, and on his/her turn, a player’s move consists of removing one or more stones from any single pile. Play ends when all the stones have been removed, at which point the last player to have moved is declared the winner. Given a position in Nim, your task is to determine how many winning moves there are in that position. A position in Nim is called “losing” if the first player to move from that position would lose if both sides played perfectly. A “winning move,” then, is a move that leaves the game in a losing position. There is a famous theorem that classifies all losing positions. Suppose a Nim position contains n piles having k1, k2, …, kn stones respectively; in such a position, there are k1 + k2 + … + kn possible moves. We write each ki in binary (base 2). Then, the Nim position is losing if and only if, among all the ki’s, there are an even number of 1’s in each digit position. In other words, the Nim position is losing if and only if the xor of the ki’s is 0. Consider the position with three piles given by k1 = 7, k2 = 11, and k3 = 13. In binary, these values are as follows: 111 1011 1101 There are an odd number of 1’s among the rightmost digits, so this position is not losing. However, suppose k3 were changed to be 12. Then, there would be exactly two 1’s in each digit position, and thus, the Nim position would become losing. Since a winning move is any move that leaves the game in a losing position, it follows that removing one stone from the third pile is a winning move when k1 = 7, k2 = 11, and k3 = 13. In fact, there are exactly three winning moves from this position: namely removing one stone from any of the three piles. <strong>Input</strong> The input test file will contain multiple test cases, each of which begins with a line indicating the number of piles, 1 ≤ n ≤ 1000. On the next line, there are n positive integers, 1 ≤ ki ≤ 1, 000, 000, 000, indicating the number of stones in each pile. The end-of-file is marked by a test case with n = 0 and should not be processed. <strong>Output</strong> For each test case, write a single line with an integer indicating the number of winning moves from the given Nim position. <strong>Sample Input</strong> 3 7 11 13 2 1000000000 1000000000 0 <strong>Sample Output</strong> 3 0 <strong>Source</strong> Stanford Local 2005 题意：组合数学的一道经典习题，有K堆硬币，两人交替取子，每人在一次取子时只能取一堆中的硬币，取至少一枚，至多全部。最后所有堆变为空堆时游戏结束，最后取子的人获胜。 给定了每堆的子数，要求输出先手者有多少种必胜策略。 思路：根据组合数学知识，若每堆硬币数异或和为0，则先手必输。若不为0，则先手有必胜策略。具体策略数枚举求得。 当枚举到第i堆硬币，若除第i堆硬币外的其他硬币异或和为x，当第i堆硬币数量a[i]大于x时，说明 1.a[i] != x, 总异或和不等于0，有必胜策略。 2.可通过从a[i]中取出一定的硬币使得总异或和为0. (若a[i]&lt;x则不满足上述第2条) 则此时策略数加1，可通过第i堆实现winner move，让对手进入losing position.如此枚举所有堆即得结果。 ac代码：</p>
<p>#include<iostream><br>using namespace std;<br>int main(){<br>    long n, a[1001];<br>    while(cin &gt;&gt; n &amp;&amp; n){<br>        for(int i = 0; i &lt; n; i++){<br>            cin &gt;&gt; a[i];<br>        }<br>        int cnt = 0;<br>        for(int i = 0; i &lt; n; i++){<br>            int sum = 0;<br>            for(int j = 0; j &lt; n; j++){<br>                if(i != j){<br>                    sum^=a[j];<br>                }<br>            }<br>            if(a[i] &gt; sum){<br>                    cnt++;<br>            }<br>        }<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    }<br>}</iostream></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/15/poj-2975-nim/" data-id="cjkf4g9up0019zp2yv19a3xlj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-poj-2975-nim-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/15/poj-2975-nim-1/" class="article-date">
  <time datetime="2016-06-15T08:42:08.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/A题/">A题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/15/poj-2975-nim-1/">POJ 2975 Nim</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>POJ 2975 Nim</strong> <strong>Description</strong> Nim is a 2-player game featuring several piles of stones. Players alternate turns, and on his/her turn, a player’s move consists of removing one or more stones from any single pile. Play ends when all the stones have been removed, at which point the last player to have moved is declared the winner. Given a position in Nim, your task is to determine how many winning moves there are in that position. A position in Nim is called “losing” if the first player to move from that position would lose if both sides played perfectly. A “winning move,” then, is a move that leaves the game in a losing position. There is a famous theorem that classifies all losing positions. Suppose a Nim position contains n piles having k1, k2, …, kn stones respectively; in such a position, there are k1 + k2 + … + kn possible moves. We write each ki in binary (base 2). Then, the Nim position is losing if and only if, among all the ki’s, there are an even number of 1’s in each digit position. In other words, the Nim position is losing if and only if the xor of the ki’s is 0. Consider the position with three piles given by k1 = 7, k2 = 11, and k3 = 13. In binary, these values are as follows: 111 1011 1101 There are an odd number of 1’s among the rightmost digits, so this position is not losing. However, suppose k3 were changed to be 12. Then, there would be exactly two 1’s in each digit position, and thus, the Nim position would become losing. Since a winning move is any move that leaves the game in a losing position, it follows that removing one stone from the third pile is a winning move when k1 = 7, k2 = 11, and k3 = 13. In fact, there are exactly three winning moves from this position: namely removing one stone from any of the three piles. <strong>Input</strong> The input test file will contain multiple test cases, each of which begins with a line indicating the number of piles, 1 ≤ n ≤ 1000. On the next line, there are n positive integers, 1 ≤ ki ≤ 1, 000, 000, 000, indicating the number of stones in each pile. The end-of-file is marked by a test case with n = 0 and should not be processed. <strong>Output</strong> For each test case, write a single line with an integer indicating the number of winning moves from the given Nim position. <strong>Sample Input</strong> 3 7 11 13 2 1000000000 1000000000 0 <strong>Sample Output</strong> 3 0 <strong>Source</strong> Stanford Local 2005 题意：组合数学的一道经典习题，有K堆硬币，两人交替取子，每人在一次取子时只能取一堆中的硬币，取至少一枚，至多全部。最后所有堆变为空堆时游戏结束，最后取子的人获胜。 给定了每堆的子数，要求输出先手者有多少种必胜策略。 思路：根据组合数学知识，若每堆硬币数异或和为0，则先手必输。若不为0，则先手有必胜策略。具体策略数枚举求得。 当枚举到第i堆硬币，若除第i堆硬币外的其他硬币异或和为x，当第i堆硬币数量a[i]大于x时，说明 1.a[i] != x, 总异或和不等于0，有必胜策略。 2.可通过从a[i]中取出一定的硬币使得总异或和为0. (若a[i]&lt;x则不满足上述第2条) 则此时策略数加1，可通过第i堆实现winner move，让对手进入losing position.如此枚举所有堆即得结果。 ac代码：</p>
<p>#include<iostream><br>using namespace std;<br>int main(){<br>    long n, a[1001];<br>    while(cin &gt;&gt; n &amp;&amp; n){<br>        for(int i = 0; i &lt; n; i++){<br>            cin &gt;&gt; a[i];<br>        }<br>        int cnt = 0;<br>        for(int i = 0; i &lt; n; i++){<br>            int sum = 0;<br>            for(int j = 0; j &lt; n; j++){<br>                if(i != j){<br>                    sum^=a[j];<br>                }<br>            }<br>            if(a[i] &gt; sum){<br>                    cnt++;<br>            }<br>        }<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    }<br>}</iostream></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/15/poj-2975-nim-1/" data-id="cjkf4itxn001c272ymys0f315" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-subset-enumeration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/24/subset-enumeration/" class="article-date">
  <time datetime="2016-05-24T07:31:03.000Z" itemprop="datePublished">2016-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/回溯/">回溯</a>►<a class="article-category-link" href="/categories/回溯/算法学习/">算法学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/24/subset-enumeration/">枚举子集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里我们讨论没有重复元素集合的非空子集枚举方法。 <strong>1.增量构造</strong> 最基本的想法就是像构造全排列那样，每次遍历所有当前可能向集合中添加的值，添加进去然后递归。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void add_subset(int n, int *A, int cur){<br>    for(int i = 0; i &lt; cur; i++){    //打印当前枚举到的集合<br>        cout&lt;&lt;A[i]&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>    int s;<br>    if(cur){    //确定当前可向集合中添加的元素的最小可能值<br>        s = A[cur-1] + 1;<br>    }else{<br>        s = 0;<br>    }<br>    for(int i = s; i &lt; n; i++){    //遍历当前所有可能取值，从当前最小可能值到集合最大值<br>        A[cur] = i;<br>        add_subset(n, A, cur+1);    //递归构造<br>    }<br>}<br>int main(){<br>    int A[99] = {0};<br>    int n;<br>    cin&gt;&gt;n;<br>    add_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0<br>0 1<br>0 1 2<br>0 2<br>1<br>1 2<br>2</p>
<p>这里我们把集合元素从0到n-1进行编号，输出中的一行代表其中一个子集中的各元素编号。 这个算法的解答树共有2^n个节点。 <strong>2.位向量构造</strong> 这里我们构造一个位向量A[i], A[i] = 1代表i出现在了子集中。这个算法很好理解，从cur = 0时开始构造子集，每一次递归只用考虑选第i个元素和不选第i个元素两种情况，递归n次即可包括2^n个子集的情况，当cur == n时则说明已经构造出了当前选择下的子集，打印输出即可。不过这个算法的解答树有2^(n+1) - 1个节点，因为每一个未完成的解也会占用一个节点。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void pos_subset(int n,int *A,int cur){<br>    if(cur == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(A[i]){<br>                cout&lt;&lt;i&lt;&lt;” “;<br>            }<br>        }<br>        cout&lt;&lt;endl;<br>        return;<br>    }<br>    A[cur] = 1;<br>    pos_subset(n, A, cur + 1);<br>    A[cur] = 0;<br>    pos_subset(n, A, cur +1);<br>}<br>int main(){<br>    int A[99]={0};<br>    int n;<br>    cin&gt;&gt;n;<br>    pos_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0 1 2<br>0 1<br>0 2<br>0<br>1 2<br>1<br>2</p>
<p>输出的定义同上。 <strong>3.二进制法</strong> 这里我们用一个二进制数来表示子集S，比如10111，即表示0,1,2,4号元素均在子集S中。也就是说，二进制数从右往左数第i位如果是1，那么该二进制数代表的集合中有元素i，0则没有。 按照这个定义，我们可以写出下面的代码来枚举子集：</p>
<p>#include<iostream><br>using namespace std;<br>void binary_subset(int n, int s){<br>    for(int i = 0; i &lt; n; i++){<br>        if(s &amp; (1 &lt;&lt; i)){<br>            cout&lt;&lt;i&lt;&lt;” “;<br>        }<br>    }<br>    cout&lt;&lt;endl;<br>}<br>int main(){<br>    int n, s;<br>    cin&gt;&gt;n;<br>    for(int i = 0; i &lt; (1 &lt;&lt; n); i++){<br>        binary_subset(n, i);<br>    } </iostream></p>
<p>}</p>
<p>测试输入：3 测试输出：</p>
<p>0<br>1<br>0 1<br>2<br>0 2<br>1 2<br>0 1 2</p>
<p>在main函数中我们枚举了子集对应的编码0到2^n-1,而binary_subset函数则负责打印编码的二进制形式所对应的子集。binary_subset函数其实就是将从右往左看子集编码的每一位是否是1，是1就打印出当前位代表的元素,和位向量法的打印是一个方法。 输出分析：输入3，然后main函数从0开始循环到2^3-1，首先是i=0，进入子集函数，s=0，无输出。main函数循环到1,子集函数1&amp;1为真，输出i=0。继续子集函数进来2=10(2)，仅第二位为1，说明该集合只取了元素1（我们从0开始编码)，于是输出该集合包含的元素1,。接着进来3=11(2)，该集合取了元素0和1，则输出0,1.以此类推直到最后循环到7=111（2),输出该集合0,1,2,至此就将含有三个元素的集合的2^n-1个非空子集枚举完了。 这里注意一下，二进制法用int存i的话，最多只能输出n=30时的集合的子集。因为int最大只有2^31-1. <strong>二进制法的一个更简洁的写法</strong> 这里先贴代码：</p>
<p>#include<iostream><br>using namespace std;<br>void print_subset(int i,int n){    //打印i的二进制形式所对应的集合的所有元素<br>    for(int j = 0; j &lt; n; j++){<br>            if(i &amp; 1&lt;&lt;j){<br>                cout &lt;&lt; j &lt;&lt;” “;<br>            }<br>        }<br>        cout &lt;&lt; endl;<br>}<br>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = n; i; i = (i - 1) &amp; n){<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>    }<br>}<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;    //输入一个数n，对应其二进制形式所代表的集合<br>    binary_subset(n);    //输出n对应集合的所有子集的编码以及每个子集中的元素 </iostream></p>
<p>}</p>
<p>其中的关键语句就只有一句</p>
<p>for(int i = n; i; i = (i - 1) &amp; n)</p>
<p>就是这句话完成了对n所代表集合的子集的枚举。而print_subset函数只是用来打印出枚举出的子集i的元素的。 这句话的关键在于i = (i - 1) &amp; n这儿，其实就是多了一个&amp;n来把n中为0的数位在自减中过滤掉了。举个栗子，输入11，即1011(2),那么这个集合含有元素0,1,3，我们做这个循环的更新，会依次得到如下的i ：</p>
<p>1011    //n的初始值，二进制形式 </p>
<p>1010    //第一次循环<br>1001    //第二次循环<br>1000    //…<br>0011<br>0010<br>0001    //当i为0000时集合为空</p>
<p>可以看出对应111,110,101,100,011,010,001. 下面可以看一下测试运行的结果，测试输入：11 测试输出：</p>
<p>11 :0 1 3<br>10 :1 3<br>9 :0 3<br>8 :3<br>3 :0 1<br>2 :1<br>1 :0</p>
<p>和我们之前分析的是一致的。 附上写法的<strong>正序版本</strong></p>
<p>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = 0; ; i = (i - n) &amp; n){    //正序<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>        if( i == n) break;<br>    }<br>}</p>
<p>输入：11 输出：</p>
<p>0 :<br>1 :0<br>2 :1<br>3 :0 1<br>8 :3<br>9 :0 3<br>10 :1 3<br>11 :0 1 3</p>
<p>另外注意当被枚举的集合n固定为2^n-1时，这样的写法就失去了意义，而退化到二进制法的情况，这时直接写</p>
<p>for(int i = 0; i &lt; (1&lt;&lt;n); i++)</p>
<p>从1到2^n-1遍历即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/24/subset-enumeration/" data-id="cjkf4g9uu001gzp2y8lm8gikz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-subset-enumeration-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/24/subset-enumeration-1/" class="article-date">
  <time datetime="2016-05-24T07:31:03.000Z" itemprop="datePublished">2016-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/回溯/">回溯</a>►<a class="article-category-link" href="/categories/回溯/算法学习/">算法学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/24/subset-enumeration-1/">枚举子集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里我们讨论没有重复元素集合的非空子集枚举方法。 <strong>1.增量构造</strong> 最基本的想法就是像构造全排列那样，每次遍历所有当前可能向集合中添加的值，添加进去然后递归。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void add_subset(int n, int *A, int cur){<br>    for(int i = 0; i &lt; cur; i++){    //打印当前枚举到的集合<br>        cout&lt;&lt;A[i]&lt;&lt;” “;<br>    }<br>    cout&lt;&lt;endl;<br>    int s;<br>    if(cur){    //确定当前可向集合中添加的元素的最小可能值<br>        s = A[cur-1] + 1;<br>    }else{<br>        s = 0;<br>    }<br>    for(int i = s; i &lt; n; i++){    //遍历当前所有可能取值，从当前最小可能值到集合最大值<br>        A[cur] = i;<br>        add_subset(n, A, cur+1);    //递归构造<br>    }<br>}<br>int main(){<br>    int A[99] = {0};<br>    int n;<br>    cin&gt;&gt;n;<br>    add_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0<br>0 1<br>0 1 2<br>0 2<br>1<br>1 2<br>2</p>
<p>这里我们把集合元素从0到n-1进行编号，输出中的一行代表其中一个子集中的各元素编号。 这个算法的解答树共有2^n个节点。 <strong>2.位向量构造</strong> 这里我们构造一个位向量A[i], A[i] = 1代表i出现在了子集中。这个算法很好理解，从cur = 0时开始构造子集，每一次递归只用考虑选第i个元素和不选第i个元素两种情况，递归n次即可包括2^n个子集的情况，当cur == n时则说明已经构造出了当前选择下的子集，打印输出即可。不过这个算法的解答树有2^(n+1) - 1个节点，因为每一个未完成的解也会占用一个节点。 示例代码如下：</p>
<p>#include<iostream><br>using namespace std;<br>void pos_subset(int n,int *A,int cur){<br>    if(cur == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(A[i]){<br>                cout&lt;&lt;i&lt;&lt;” “;<br>            }<br>        }<br>        cout&lt;&lt;endl;<br>        return;<br>    }<br>    A[cur] = 1;<br>    pos_subset(n, A, cur + 1);<br>    A[cur] = 0;<br>    pos_subset(n, A, cur +1);<br>}<br>int main(){<br>    int A[99]={0};<br>    int n;<br>    cin&gt;&gt;n;<br>    pos_subset(n, A, 0);<br>}</iostream></p>
<p>测试输入： 3 测试输出：</p>
<p>0 1 2<br>0 1<br>0 2<br>0<br>1 2<br>1<br>2</p>
<p>输出的定义同上。 <strong>3.二进制法</strong> 这里我们用一个二进制数来表示子集S，比如10111，即表示0,1,2,4号元素均在子集S中。也就是说，二进制数从右往左数第i位如果是1，那么该二进制数代表的集合中有元素i，0则没有。 按照这个定义，我们可以写出下面的代码来枚举子集：</p>
<p>#include<iostream><br>using namespace std;<br>void binary_subset(int n, int s){<br>    for(int i = 0; i &lt; n; i++){<br>        if(s &amp; (1 &lt;&lt; i)){<br>            cout&lt;&lt;i&lt;&lt;” “;<br>        }<br>    }<br>    cout&lt;&lt;endl;<br>}<br>int main(){<br>    int n, s;<br>    cin&gt;&gt;n;<br>    for(int i = 0; i &lt; (1 &lt;&lt; n); i++){<br>        binary_subset(n, i);<br>    } </iostream></p>
<p>}</p>
<p>测试输入：3 测试输出：</p>
<p>0<br>1<br>0 1<br>2<br>0 2<br>1 2<br>0 1 2</p>
<p>在main函数中我们枚举了子集对应的编码0到2^n-1,而binary_subset函数则负责打印编码的二进制形式所对应的子集。binary_subset函数其实就是将从右往左看子集编码的每一位是否是1，是1就打印出当前位代表的元素,和位向量法的打印是一个方法。 输出分析：输入3，然后main函数从0开始循环到2^3-1，首先是i=0，进入子集函数，s=0，无输出。main函数循环到1,子集函数1&amp;1为真，输出i=0。继续子集函数进来2=10(2)，仅第二位为1，说明该集合只取了元素1（我们从0开始编码)，于是输出该集合包含的元素1,。接着进来3=11(2)，该集合取了元素0和1，则输出0,1.以此类推直到最后循环到7=111（2),输出该集合0,1,2,至此就将含有三个元素的集合的2^n-1个非空子集枚举完了。 这里注意一下，二进制法用int存i的话，最多只能输出n=30时的集合的子集。因为int最大只有2^31-1. <strong>二进制法的一个更简洁的写法</strong> 这里先贴代码：</p>
<p>#include<iostream><br>using namespace std;<br>void print_subset(int i,int n){    //打印i的二进制形式所对应的集合的所有元素<br>    for(int j = 0; j &lt; n; j++){<br>            if(i &amp; 1&lt;&lt;j){<br>                cout &lt;&lt; j &lt;&lt;” “;<br>            }<br>        }<br>        cout &lt;&lt; endl;<br>}<br>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = n; i; i = (i - 1) &amp; n){<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>    }<br>}<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;    //输入一个数n，对应其二进制形式所代表的集合<br>    binary_subset(n);    //输出n对应集合的所有子集的编码以及每个子集中的元素 </iostream></p>
<p>}</p>
<p>其中的关键语句就只有一句</p>
<p>for(int i = n; i; i = (i - 1) &amp; n)</p>
<p>就是这句话完成了对n所代表集合的子集的枚举。而print_subset函数只是用来打印出枚举出的子集i的元素的。 这句话的关键在于i = (i - 1) &amp; n这儿，其实就是多了一个&amp;n来把n中为0的数位在自减中过滤掉了。举个栗子，输入11，即1011(2),那么这个集合含有元素0,1,3，我们做这个循环的更新，会依次得到如下的i ：</p>
<p>1011    //n的初始值，二进制形式 </p>
<p>1010    //第一次循环<br>1001    //第二次循环<br>1000    //…<br>0011<br>0010<br>0001    //当i为0000时集合为空</p>
<p>可以看出对应111,110,101,100,011,010,001. 下面可以看一下测试运行的结果，测试输入：11 测试输出：</p>
<p>11 :0 1 3<br>10 :1 3<br>9 :0 3<br>8 :3<br>3 :0 1<br>2 :1<br>1 :0</p>
<p>和我们之前分析的是一致的。 附上写法的<strong>正序版本</strong></p>
<p>void binary_subset(int n){    //枚举n的二进制形式所代表集合的所有子集<br>    for(int i = 0; ; i = (i - n) &amp; n){    //正序<br>        cout&lt;&lt;i&lt;&lt;” :”;    //每一个i的二进制形式代表一个子集<br>        print_subset(i,n);    //输出该子集中的元素<br>        if( i == n) break;<br>    }<br>}</p>
<p>输入：11 输出：</p>
<p>0 :<br>1 :0<br>2 :1<br>3 :0 1<br>8 :3<br>9 :0 3<br>10 :1 3<br>11 :0 1 3</p>
<p>另外注意当被枚举的集合n固定为2^n-1时，这样的写法就失去了意义，而退化到二进制法的情况，这时直接写</p>
<p>for(int i = 0; i &lt; (1&lt;&lt;n); i++)</p>
<p>从1到2^n-1遍历即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/24/subset-enumeration-1/" data-id="cjkf4itxp001g272y4nk7u878" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-uva-140-bandwidth-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/23/uva-140-bandwidth-1/" class="article-date">
  <time datetime="2016-05-23T14:18:50.000Z" itemprop="datePublished">2016-05-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Uva/">Uva</a>►<a class="article-category-link" href="/categories/Uva/回溯/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/23/uva-140-bandwidth-1/">Uva 140 Bandwidth</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Uva 140 Bandwidth</strong> Given a graph (V,E) where V is a set of nodes and E is a set of arcs in VxV, and an ordering on the elements in V, then the bandwidth of a node v is defined as the maximum distance in the ordering between v and any node to which it is connected in the graph. The bandwidth of the ordering is then defined as the maximum of the individual bandwidths. For example, consider the following graph: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img1.gif" alt="140img1"> This can be ordered in many ways, two of which are illustrated below: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img2-300x34.gif" alt="140img2"> For these orderings, the bandwidths of the nodes (in order) are 6, 6, 1, 4, 1, 1, 6, 6 giving an ordering bandwidth of 6, and 5, 3, 1, 4, 3, 5, 1, 4 giving an ordering bandwidth of 5. Write a program that will find the ordering of a graph that minimises the bandwidth. <strong>Input</strong> Input will consist of a series of graphs. Each graph will appear on a line by itself. The entire file will be terminated by a line consisting of a single #. For each graph, the input will consist of a series of records separated by <code>;&#39;. Each record will consist of a node name (a single upper case character in the the range \</code>A’ to `Z’), followed by a `:’ and at least one of its neighbours. The graph will contain no more than 8 nodes. <strong>Output</strong> Output will consist of one line for each graph, listing the ordering of the nodes followed by an arrow (-&gt;) and the bandwidth for that ordering. All items must be separated from their neighbours by exactly one space. If more than one ordering produces the same bandwidth, then choose the smallest in lexicographic ordering, that is the one that would appear first in an alphabetic listing. <strong>Sample input</strong> A:FB;B:GC;D:GC;F:AGH;E:HD # <strong>Sample output</strong> A B C F G D H E -&gt; 3 题意：输入一个无向图G，定义一个由图的顶点构成的排列P. 定义任意一个顶点i的带宽b(i), 为i顶点与其相邻顶点在排列P中的最远距离。取所有顶点的b(i)的最大值为整个图G的bandwidth. 要求输出一个让bandwidth最小的顶点排列并输出其bandwidth值. 思路：因为图顶点数&lt;=8, 排列数小于100000, 所以这里直接用的暴力枚举。首先读入一行数据，然后用strchr函数(返回字符串str中第一次出现字符ch时的指针，如果没有出现则返回NULL)对本次输入出现的字母进行编号。通过mapc数组得到从编号到字母的映射，通过id数组得到字母到其编号的映射。 然后遍历输入，直接用向量u，v储存所有相邻的顶点，在循环中，u反复存储当前顶点，而对应的v则存入其相邻顶点，直到分号输入为止。这样就将所有会用来计算带宽的点对对应的存入了u，v中。 最后通过c++自带的next_permutation函数按字典序生成全排列。先初始化最小字典序全排列，然后循环生成。 这道题除了暴力的做法，还可以回溯剪枝，而且显然更快。这儿先留着下次有时间再写。 ac代码：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring></cstring></p>
<p>#include<algorithm></algorithm></p>
<p>#include<cmath></cmath></p>
<p>#include<vector></vector></p>
<p>#define N 10<br>using namespace std;<br>char in[100];<br>char mapc[30];<br>int id[30];<br>vector<int> u, v;<br>int main(){<br>    while(~scanf(“%s”,&amp;in) &amp;&amp; in[0] != ‘#’){<br>        int p = 0, num = 0, flag = 0;<br>        for(char a = ‘A’; a &lt;= ‘Z’; a++){<br>            if(strchr(in, a) != NULL){<br>                mapc[num] = a;<br>                id[a] = num;<br>                num++;<br>            }<br>        }<br>        char ch;<br>        int len = strlen(in);<br>        for(int i = 0; i &lt; len; i++){<br>            if(in[i] == ‘:’){<br>                flag = 1;<br>            }<br>            if(!flag){<br>                ch = in[i];<br>            }<br>            if(flag &amp;&amp; in[i] != ‘:’){<br>                if(in[i] != ‘;’){<br>                    u.push_back(id[ch]);<br>                    v.push_back(id[in[i]]);<br>                }<br>                else{<br>                    flag = 0;<br>                }<br>            }</int></p>
<pre><code>    }
    int pa\[N\], ans\[N\], pos\[N\], bw = 0x3f3f3f3f;
    for(int i = 0; i &lt; num; i++){
        pa\[i\] = i;
    }
    do{
        for(int i = 0; i &lt; num; i++){
            pos\[pa\[i\]\] = i;
        } 
        int b = 0;
        for(int i = 0; i &lt; u.size(); i++){
            b = max(b, abs(pos\[u\[i\]\]-pos\[v\[i\]\]));
        }
        if(b &lt; bw){
            bw = b;
            memcpy(ans, pa, sizeof(pa));
        }
    }while(next_permutation(pa, pa + num));
    for(int i = 0; i &lt; num; i++){
        printf(&quot;%c &quot;, mapc\[ans\[i\]\]);
    }
    printf(&quot;-&gt; %d\\n&quot;, bw);
    u.clear();
    v.clear();
    memset(mapc, 0, sizeof(mapc));
    memset(in, 0, sizeof(in));
    memset(id, 0, sizeof(id));
}
return 0;
</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/23/uva-140-bandwidth-1/" data-id="cjkf4itxz001w272yrgk7q3o6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-uva-140-bandwidth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/23/uva-140-bandwidth/" class="article-date">
  <time datetime="2016-05-23T14:18:50.000Z" itemprop="datePublished">2016-05-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Uva/">Uva</a>►<a class="article-category-link" href="/categories/Uva/回溯/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/23/uva-140-bandwidth/">Uva 140 Bandwidth</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Uva 140 Bandwidth</strong> Given a graph (V,E) where V is a set of nodes and E is a set of arcs in VxV, and an ordering on the elements in V, then the bandwidth of a node v is defined as the maximum distance in the ordering between v and any node to which it is connected in the graph. The bandwidth of the ordering is then defined as the maximum of the individual bandwidths. For example, consider the following graph: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img1.gif" alt="140img1"> This can be ordered in many ways, two of which are illustrated below: <img src="http://fanyijie.net/wp-content/uploads/2016/05/140img2-300x34.gif" alt="140img2"> For these orderings, the bandwidths of the nodes (in order) are 6, 6, 1, 4, 1, 1, 6, 6 giving an ordering bandwidth of 6, and 5, 3, 1, 4, 3, 5, 1, 4 giving an ordering bandwidth of 5. Write a program that will find the ordering of a graph that minimises the bandwidth. <strong>Input</strong> Input will consist of a series of graphs. Each graph will appear on a line by itself. The entire file will be terminated by a line consisting of a single #. For each graph, the input will consist of a series of records separated by <code>;&#39;. Each record will consist of a node name (a single upper case character in the the range \</code>A’ to `Z’), followed by a `:’ and at least one of its neighbours. The graph will contain no more than 8 nodes. <strong>Output</strong> Output will consist of one line for each graph, listing the ordering of the nodes followed by an arrow (-&gt;) and the bandwidth for that ordering. All items must be separated from their neighbours by exactly one space. If more than one ordering produces the same bandwidth, then choose the smallest in lexicographic ordering, that is the one that would appear first in an alphabetic listing. <strong>Sample input</strong> A:FB;B:GC;D:GC;F:AGH;E:HD # <strong>Sample output</strong> A B C F G D H E -&gt; 3 题意：输入一个无向图G，定义一个由图的顶点构成的排列P. 定义任意一个顶点i的带宽b(i), 为i顶点与其相邻顶点在排列P中的最远距离。取所有顶点的b(i)的最大值为整个图G的bandwidth. 要求输出一个让bandwidth最小的顶点排列并输出其bandwidth值. 思路：因为图顶点数&lt;=8, 排列数小于100000, 所以这里直接用的暴力枚举。首先读入一行数据，然后用strchr函数(返回字符串str中第一次出现字符ch时的指针，如果没有出现则返回NULL)对本次输入出现的字母进行编号。通过mapc数组得到从编号到字母的映射，通过id数组得到字母到其编号的映射。 然后遍历输入，直接用向量u，v储存所有相邻的顶点，在循环中，u反复存储当前顶点，而对应的v则存入其相邻顶点，直到分号输入为止。这样就将所有会用来计算带宽的点对对应的存入了u，v中。 最后通过c++自带的next_permutation函数按字典序生成全排列。先初始化最小字典序全排列，然后循环生成。 这道题除了暴力的做法，还可以回溯剪枝，而且显然更快。这儿先留着下次有时间再写。 ac代码：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cstring></cstring></p>
<p>#include<algorithm></algorithm></p>
<p>#include<cmath></cmath></p>
<p>#include<vector></vector></p>
<p>#define N 10<br>using namespace std;<br>char in[100];<br>char mapc[30];<br>int id[30];<br>vector<int> u, v;<br>int main(){<br>    while(~scanf(“%s”,&amp;in) &amp;&amp; in[0] != ‘#’){<br>        int p = 0, num = 0, flag = 0;<br>        for(char a = ‘A’; a &lt;= ‘Z’; a++){<br>            if(strchr(in, a) != NULL){<br>                mapc[num] = a;<br>                id[a] = num;<br>                num++;<br>            }<br>        }<br>        char ch;<br>        int len = strlen(in);<br>        for(int i = 0; i &lt; len; i++){<br>            if(in[i] == ‘:’){<br>                flag = 1;<br>            }<br>            if(!flag){<br>                ch = in[i];<br>            }<br>            if(flag &amp;&amp; in[i] != ‘:’){<br>                if(in[i] != ‘;’){<br>                    u.push_back(id[ch]);<br>                    v.push_back(id[in[i]]);<br>                }<br>                else{<br>                    flag = 0;<br>                }<br>            }</int></p>
<pre><code>    }
    int pa\[N\], ans\[N\], pos\[N\], bw = 0x3f3f3f3f;
    for(int i = 0; i &lt; num; i++){
        pa\[i\] = i;
    }
    do{
        for(int i = 0; i &lt; num; i++){
            pos\[pa\[i\]\] = i;
        } 
        int b = 0;
        for(int i = 0; i &lt; u.size(); i++){
            b = max(b, abs(pos\[u\[i\]\]-pos\[v\[i\]\]));
        }
        if(b &lt; bw){
            bw = b;
            memcpy(ans, pa, sizeof(pa));
        }
    }while(next_permutation(pa, pa + num));
    for(int i = 0; i &lt; num; i++){
        printf(&quot;%c &quot;, mapc\[ans\[i\]\]);
    }
    printf(&quot;-&gt; %d\\n&quot;, bw);
    u.clear();
    v.clear();
    memset(mapc, 0, sizeof(mapc));
    memset(in, 0, sizeof(in));
    memset(id, 0, sizeof(id));
}
return 0;
</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/23/uva-140-bandwidth/" data-id="cjkf4g9vy0036zp2y5pfebjps" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-uva-129-krypton-factor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/18/uva-129-krypton-factor/" class="article-date">
  <time datetime="2016-05-18T07:58:52.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Uva/">Uva</a>►<a class="article-category-link" href="/categories/Uva/回溯/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/uva-129-krypton-factor/">Uva 129 Krypton Factor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Uva 129 Krypton Factor</strong> You have been employed by the organisers of a Super Krypton Factor Contest in which contestants have very high mental and physical abilities. In one section of the contest the contestants are tested on their ability to recall a sequence of characters which has been read to them by the Quiz Master. Many of the contestants are very good at recognising patterns. Therefore, in order to add some difficulty to this test, the organisers have decided that sequences containing certain types of repeated subsequences should not be used. However, they do not wish to remove all subsequences that are repeated, since in that case no single character could be repeated. This in itself would make the problem too easy for the contestants. Instead it is decided to eliminate all sequences containing an occurrence of two adjoining identical subsequences. Sequences containing such an occurrence will be called ``easy’’. Other sequences will be called ``hard’’. For example, the sequence ABACBCBAD is easy, since it contains an adjoining repetition of the subsequence CB. Other examples of easy sequences are: BB ABCDACABCAB ABCDABCD Some examples of hard sequences are: D DC ABDAB CBABCBA <strong>Input and Output</strong> In order to provide the Quiz Master with a potentially unlimited source of questions you are asked to write a program that will read input lines that contain integers n and L (in that order), where n &gt; 0 and L is in the range 1 &lt;= L &lt;= 26 , and for each input line prints out the nth hard sequence (composed of letters drawn from the first L letters in the alphabet), in increasing alphabetical order (alphabetical ordering here corresponds to the normal ordering encountered in a dictionary), followed (on the next line) by the length of that sequence. The first sequence in this ordering is A. You may assume that for given n and L there do exist at least n hard sequences. For example, with L = 3, the first 7 hard sequences are: A AB ABA ABAC ABACA ABACAB ABACABA As each sequence is potentially very long, split it into groups of four (4) characters separated by a space. If there are more than 16 such groups, please start a new line for the 17th group. Therefore, if the integers 7 and 3 appear on an input line, the output lines produced should be ABAC ABA 7 Input is terminated by a line containing two zeroes. Your program may assume a maximum sequence length of 80. <strong>Sample Input</strong> 30 3 0 0 <strong>Sample Output</strong> ABAC ABCA CBAB CABA CABC ACBA CABA 28 题意：输入n和l,输出字典序第n小的hard串。 hard的定义是字符串中不包含相邻的重复子串。字符串由A, B, C,…,从A开始的l个字母构成。 思路：和生成全排列的方法类似，每次向当前位置尝试添加一个字母，如果该字母和之前已放置的字母冲突，则按字典序继续循环尝试放置下一个字母，直到不冲突的时候就放置进去并进入下一层（下一位置）的递归。 递归的边界条件在这里需要一个全局变量cnt来判断。由于每进一次递归，cnt都会++, 而一旦能进入一次递归，则说明已经又找到了一个hard串了，所以当cnt++ == n,即cnt == n时，正好是字典序第n小的hard串生成完成的时候。这时候也就是递归成功的边界条件了. 这里由于只要达到目标就不用继续搜索下去，所以在边界条件中有return 0,表示搜索成功，这样在上一层递归if(!dfs(cur+1)) return 0 中，就可以直接继续return 0跳过循环退出,然后一层层快速跳出递归，避免无用搜索。如果走到叶子节点也未找到解，就会执行最后的return 1返回父节点，然后继续循环遍历父节点剩下的儿子。如果儿子遍历完仍未找到解，则会继续返回上一层父节点，然后继续遍历深入，直到搜索完所有节点或者找到解为止。 这里取值i是否尝试成功的条件判断，是通过遍历了当前字符串长度cur+1范围内所有偶数长度的后缀，循环进行测试而得到的。 对于每一次的尝试取值i，检查所有偶数长度的后缀。每次检查当前2*j长度的后缀的前一半和后一半是否完全相同。如果有一个字符不同，则eq = 0并break，说明对于当前后缀是没有重复的，j++并对下一个后缀长度2*j再次测试。 如果测试完所有能取到的后缀长度后，均没有发现重复子串，则说明字符串是ok的，可以进入下一个位置的递归；而只要其中有一次发现了重复子串，则eq = 1，ok = 0，不是hard串，无法进入下一位置的递归，只能对当前位置的取值i继续按字典序进行循环尝试，直到将循环完毕返回父节点或找到解退出递归为止。 ac代码如下：</p>
<p>#include<cstdio><br>using namespace std;<br>int n, l, cnt;<br>int S[82];<br>int dfs(int cur){    //return 0 means solution has found<br>    if(cnt++ == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(i &amp;&amp; i % 64 == 0) printf(“\n”);<br>            else if(i &amp;&amp; i % 4 == 0) printf(“ “);<br>            printf(“%c”, ‘A’+S[i]);<br>        }<br>        printf(“\n%d\n”, cur);<br>        return 0;<br>    }<br>    for(int i = 0; i &lt; l; i++){<br>        S[cur] = i;<br>        bool ok = 1;<br>        for(int j = 1; j*2 &lt;= cur+1; j++){    //每添加一个数，就对所有后一半包含新数的后缀进行测试<br>            bool eq = 1;<br>            for(int k = 0; k &lt; j; k++){        //测试当前后缀长度下，后缀的前一半是否等于后一半<br>                if(S[cur-k] != S[cur-k-j]){    //对前一半和后一半的对应字符逐个比较<br>                    eq = 0;<br>                    break;<br>                }<br>            }<br>            if(eq){<br>                ok = 0;<br>                break;<br>            }<br>        }<br>        if(ok){<br>            if(!dfs(cur+1)){    // 如果已经找到解，则退出<br>                return 0;<br>            }<br>        }</cstdio></p>
<pre><code>}
return 1;
</code></pre><p>}<br>int main(){<br>    while(scanf(“%d%d”, &amp;n, &amp;l) == 2 &amp;&amp; n){<br>        cnt = 0;<br>        dfs(0);<br>    }<br>    return 0;<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/18/uva-129-krypton-factor/" data-id="cjkf4g9v2001tzp2yq12y5z6d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-uva-129-krypton-factor-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/18/uva-129-krypton-factor-1/" class="article-date">
  <time datetime="2016-05-18T07:58:52.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Uva/">Uva</a>►<a class="article-category-link" href="/categories/Uva/回溯/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/uva-129-krypton-factor-1/">Uva 129 Krypton Factor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Uva 129 Krypton Factor</strong> You have been employed by the organisers of a Super Krypton Factor Contest in which contestants have very high mental and physical abilities. In one section of the contest the contestants are tested on their ability to recall a sequence of characters which has been read to them by the Quiz Master. Many of the contestants are very good at recognising patterns. Therefore, in order to add some difficulty to this test, the organisers have decided that sequences containing certain types of repeated subsequences should not be used. However, they do not wish to remove all subsequences that are repeated, since in that case no single character could be repeated. This in itself would make the problem too easy for the contestants. Instead it is decided to eliminate all sequences containing an occurrence of two adjoining identical subsequences. Sequences containing such an occurrence will be called ``easy’’. Other sequences will be called ``hard’’. For example, the sequence ABACBCBAD is easy, since it contains an adjoining repetition of the subsequence CB. Other examples of easy sequences are: BB ABCDACABCAB ABCDABCD Some examples of hard sequences are: D DC ABDAB CBABCBA <strong>Input and Output</strong> In order to provide the Quiz Master with a potentially unlimited source of questions you are asked to write a program that will read input lines that contain integers n and L (in that order), where n &gt; 0 and L is in the range 1 &lt;= L &lt;= 26 , and for each input line prints out the nth hard sequence (composed of letters drawn from the first L letters in the alphabet), in increasing alphabetical order (alphabetical ordering here corresponds to the normal ordering encountered in a dictionary), followed (on the next line) by the length of that sequence. The first sequence in this ordering is A. You may assume that for given n and L there do exist at least n hard sequences. For example, with L = 3, the first 7 hard sequences are: A AB ABA ABAC ABACA ABACAB ABACABA As each sequence is potentially very long, split it into groups of four (4) characters separated by a space. If there are more than 16 such groups, please start a new line for the 17th group. Therefore, if the integers 7 and 3 appear on an input line, the output lines produced should be ABAC ABA 7 Input is terminated by a line containing two zeroes. Your program may assume a maximum sequence length of 80. <strong>Sample Input</strong> 30 3 0 0 <strong>Sample Output</strong> ABAC ABCA CBAB CABA CABC ACBA CABA 28 题意：输入n和l,输出字典序第n小的hard串。 hard的定义是字符串中不包含相邻的重复子串。字符串由A, B, C,…,从A开始的l个字母构成。 思路：和生成全排列的方法类似，每次向当前位置尝试添加一个字母，如果该字母和之前已放置的字母冲突，则按字典序继续循环尝试放置下一个字母，直到不冲突的时候就放置进去并进入下一层（下一位置）的递归。 递归的边界条件在这里需要一个全局变量cnt来判断。由于每进一次递归，cnt都会++, 而一旦能进入一次递归，则说明已经又找到了一个hard串了，所以当cnt++ == n,即cnt == n时，正好是字典序第n小的hard串生成完成的时候。这时候也就是递归成功的边界条件了. 这里由于只要达到目标就不用继续搜索下去，所以在边界条件中有return 0,表示搜索成功，这样在上一层递归if(!dfs(cur+1)) return 0 中，就可以直接继续return 0跳过循环退出,然后一层层快速跳出递归，避免无用搜索。如果走到叶子节点也未找到解，就会执行最后的return 1返回父节点，然后继续循环遍历父节点剩下的儿子。如果儿子遍历完仍未找到解，则会继续返回上一层父节点，然后继续遍历深入，直到搜索完所有节点或者找到解为止。 这里取值i是否尝试成功的条件判断，是通过遍历了当前字符串长度cur+1范围内所有偶数长度的后缀，循环进行测试而得到的。 对于每一次的尝试取值i，检查所有偶数长度的后缀。每次检查当前2*j长度的后缀的前一半和后一半是否完全相同。如果有一个字符不同，则eq = 0并break，说明对于当前后缀是没有重复的，j++并对下一个后缀长度2*j再次测试。 如果测试完所有能取到的后缀长度后，均没有发现重复子串，则说明字符串是ok的，可以进入下一个位置的递归；而只要其中有一次发现了重复子串，则eq = 1，ok = 0，不是hard串，无法进入下一位置的递归，只能对当前位置的取值i继续按字典序进行循环尝试，直到将循环完毕返回父节点或找到解退出递归为止。 ac代码如下：</p>
<p>#include<cstdio><br>using namespace std;<br>int n, l, cnt;<br>int S[82];<br>int dfs(int cur){    //return 0 means solution has found<br>    if(cnt++ == n){<br>        for(int i = 0; i &lt; cur; i++){<br>            if(i &amp;&amp; i % 64 == 0) printf(“\n”);<br>            else if(i &amp;&amp; i % 4 == 0) printf(“ “);<br>            printf(“%c”, ‘A’+S[i]);<br>        }<br>        printf(“\n%d\n”, cur);<br>        return 0;<br>    }<br>    for(int i = 0; i &lt; l; i++){<br>        S[cur] = i;<br>        bool ok = 1;<br>        for(int j = 1; j*2 &lt;= cur+1; j++){    //每添加一个数，就对所有后一半包含新数的后缀进行测试<br>            bool eq = 1;<br>            for(int k = 0; k &lt; j; k++){        //测试当前后缀长度下，后缀的前一半是否等于后一半<br>                if(S[cur-k] != S[cur-k-j]){    //对前一半和后一半的对应字符逐个比较<br>                    eq = 0;<br>                    break;<br>                }<br>            }<br>            if(eq){<br>                ok = 0;<br>                break;<br>            }<br>        }<br>        if(ok){<br>            if(!dfs(cur+1)){    // 如果已经找到解，则退出<br>                return 0;<br>            }<br>        }</cstdio></p>
<pre><code>}
return 1;
</code></pre><p>}<br>int main(){<br>    while(scanf(“%d%d”, &amp;n, &amp;l) == 2 &amp;&amp; n){<br>        cnt = 0;<br>        dfs(0);<br>    }<br>    return 0;<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/18/uva-129-krypton-factor-1/" data-id="cjkf4itxx001u272yxawilrna" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-uva-524-prime-ring-problem-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/18/uva-524-prime-ring-problem-1/" class="article-date">
  <time datetime="2016-05-18T06:10:44.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Uva/">Uva</a>►<a class="article-category-link" href="/categories/Uva/回溯/">回溯</a>►<a class="article-category-link" href="/categories/Uva/回溯/数论/">数论</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/uva-524-prime-ring-problem-1/">Uva 524 Prime Ring Problem</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Uva 524 Prime Ring Problem</strong> A ring is composed of n (even number) circles as shown in diagram. Put natural numbers 1, 2, . . . , n into each circle separately, and the sum of numbers in two adjacent circles should be a prime. Note: the number of first circle should always be 1. <strong>Input</strong> n (0 &lt; n ≤ 16) <strong>Output</strong> The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements. You are to write a program that completes above process. <strong>Sample Input</strong> 6 8 <strong>Sample Output</strong> Case 1: 1 4 3 2 5 6 1 6 5 2 3 4 Case 2: 1 2 3 8 5 6 7 4 1 2 5 8 3 4 7 6 1 4 7 6 5 8 3 2 1 6 7 4 3 8 5 2 题意：生成一个素数环，使得相邻两个整数之和为素数，包括首尾。素数环由1~n组成，输出从1开始逆时针排列。 思路：和生成全排列的模型类似，直接递归深度优先遍历解答树，递归边界条件为cur == n且第一个数和最后一个数之和为素数，尝试取值的循环直接从2到n即可，因为要求从1开始输出，所以1每次直接加到输出数组第一个就行了。 尝试是否成功的判断条件就很简单了，一个通用的!vis[i] 和 !icp[i + A[cur-1]]，即i这个数没有被用到过且i和前一个放置的数之和为素数即可。这里素数的判定用的是先素数筛法生成素数表，然后直接用素数表判断的。 注意一下输出排列时，有一个if(i) printf(“ “)，以防止在一个排列最后同时输出空格与换行而PE. ac代码如下：</p>
<p>#include<cstdio></cstdio></p>
<p>#include<cmath></cmath></p>
<p>#include<cstring><br>using namespace std;<br>int n,A[99];<br>bool vis[99];<br>bool isc[101];<br>void get_prime(int n){<br>    int m=sqrt(n+0.5);<br>    for(int i = 2; i &lt;= m; i++){<br>        if(!isc[i]){<br>            for(int j = i*i; j &lt;= n; j+=i){<br>                isc[j] = 1;<br>            }<br>        }<br>    }<br>}<br>void dfs(int cur){<br>    if(cur == n &amp;&amp; !isc[A[0] + A[n-1]]){<br>        for(int i = 0; i &lt; n; i++){<br>            if(i) printf(“ “);<br>            printf(“%d”,A[i]);<br>        }<br>        printf(“\n”);<br>    }<br>    else for(int i = 2; i &lt;= n; i++){<br>        if(!vis[i] &amp;&amp; !isc[i+A[cur-1]]){<br>            A[cur] = i;<br>            vis[i] = 1;<br>            dfs(cur+1);<br>            vis[i] = 0;<br>        }<br>    }<br>}<br>int main(){<br>    get_prime(100);<br>    isc[0]=isc[1]=1;<br>    int kase = 0;<br>    while(~scanf(“%d”, &amp;n)){<br>        if(kase &gt; 0) printf(“\n”);<br>        printf(“Case %d:\n”, ++kase);<br>        memset(vis, 0, sizeof(vis));<br>        A[0] = 1;<br>        dfs(1);<br>    }<br>    return 0;<br>}</cstring></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/18/uva-524-prime-ring-problem-1/" data-id="cjkf4ity0001y272y33w3604r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/A题/">A题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/A题/回溯/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/A题/数论/">数论</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ethereum/">Ethereum</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Uva/">Uva</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Uva/回溯/">回溯</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Uva/回溯/数论/">数论</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/eos/">eos</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/eos/Ethereum/">Ethereum</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/eos/Ethereum/经验杂谈/">经验杂谈</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">ios</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ios/经验杂谈/">经验杂谈</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/unity/">unity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/关于我/">关于我</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/关于我/经验杂谈/">经验杂谈</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治/">分治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/回溯/">回溯</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/回溯/算法学习/">算法学习</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术分享/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/经验杂谈/">经验杂谈</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/04/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/05/14/trouble-shooting-on-eos-1/">Trouble Shooting on EOS</a>
          </li>
        
          <li>
            <a href="/2018/05/14/trouble-shooting-on-eos/">Trouble Shooting on EOS</a>
          </li>
        
          <li>
            <a href="/2018/05/08/the-difference-of-ether-and-eos-token-in-code-hierarchy-aspect/">The difference of Ether and EOS token in code hierarchy aspect</a>
          </li>
        
          <li>
            <a href="/2018/05/08/the-difference-of-ether-and-eos-token-in-code-hierarchy-aspect-1/">The difference of Ether and EOS token in code hierarchy aspect</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>